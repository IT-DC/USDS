/*************************************************************/
/* Copyright (C) 2015 OSS Nokalva, Inc.  All rights reserved.*/
/*************************************************************/

/* THIS FILE IS PROPRIETARY MATERIAL OF OSS NOKALVA, INC.
 * AND MAY BE USED ONLY BY DIRECT LICENSEES OF OSS NOKALVA, INC.
 * THIS FILE MAY NOT BE DISTRIBUTED.
 * THIS COPYRIGHT STATEMENT MAY NOT BE REMOVED. */

/* This file was generated by a TRIAL version of the OSS ASN.1 Tools.
 * Applications built using this file can be executed only on the machine
 * on which you run the OSS ASN.1 compiler. */

/* Generated for: IT-DC (Trial), License 70926Z. */
/* Abstract syntax: asn_bench */
/* Created: Wed Jul 01 14:40:19 2015 */
/* ASN.1/C++ compiler version: 6.1 */
/* Code generated for runtime version 6.1 or later */
/* Compiler operating system: Windows */
/* Compiler machine type: Intel x86 */
/* Target operating system: Windows */
/* Target machine type: Intel x86 */
/* C++ compiler options required: -Zp8 (Microsoft) */
/* ASN.1 compiler options and file names specified:
 * -warningmessages -informatorymessages -2008 -per -ber -der -xer -oer -root
 * -sampleCode -messageFormat msvc -allow universaltags
 * D:/Temp/61/ASN/asn_bench.asn
 */

#define OSS_COMPILER_API_LEVEL 32
#define _OSS_CODE_FILE
#define OSS_TOED_BER
#define OSS_TOED_PER
#define OSS_TOED_XER
#define OSS_TOED_OER
#include "asn_bench.h"
#include "string.h"

#include "osstype.h"

#if OSSDEBUG > 1
#define OSS_CNTX_INIT _Context_Element _element;  _element._occurrence = 0;
#define OSS_CNTX_INITZERO _Context_Element _element = {NULL, NULL, 0};
#define OSS_CNTX_ZEROOCC  _element._occurrence = 0;
#define OSS_CNTX_INCOCC  _element._occurrence++;
#define OSS_CNTX_SETOCC(OCC) _element._occurrence = OCC;
#define OSS_CNTX_DEF _Context_Element _element;
#define OSS_CNTX_POP(OSSCNAME) OSSCNAME->_oss_context_anchor._last = _element._parent;
#define OSS_CNTX_PUSH(OSSCNAME,CNTXID) _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _element._parent = OSSCNAME->_oss_context_anchor._last;\
    OSSCNAME->_oss_context_anchor._last = &_element;
#define OSS_CNTX_SET(CNTXID) _element._id = (_Context_Id *)&_context_id[CNTXID];
#define OSS_CNTX_NEW(OSSCNAME,CNTXID) _Context_Element _element;\
    _element._occurrence = 0;\
    _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _element._parent = OSSCNAME->_oss_context_anchor._last;\
    OSSCNAME->_oss_context_anchor._last = &_element;
#define OSS_CNTX_ANCHOR_SET(PDU,CNTXID) \
    _element._parent = _oss_c->_oss_context_anchor._last;\
    _element._id = (_Context_Id *)&_context_id[CNTXID];\
    _oss_c->_oss_context_anchor._last = &_element;\
    if (!_oss_c->_oss_context_anchor._pdu_number) {\
        _oss_c->_oss_context_anchor._pdu_number = PDU;\
        _oss_c->_oss_context_anchor._pdu_id = _element._id;\
    }
#define OSS_CNTX_OSSC_DEF _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
#else
#define OSS_CNTX_INIT
#define OSS_CNTX_INITZERO
#define OSS_CNTX_ZEROOCC
#define OSS_CNTX_INCOCC
#define OSS_CNTX_SETOCC(OCC)
#define OSS_CNTX_DEF
#define OSS_CNTX_POP(OSSCNAME)
#define OSS_CNTX_PUSH(OSSCNAME,CNTXID)
#define OSS_CNTX_SET(CNTXID)
#define OSS_CNTX_NEW(OSSCNAME,CNTXID)
#define OSS_CNTX_ANCHOR_SET(PDU,CNTXID) _oss_c->_oss_context_anchor._pdu_number = 0;
#endif
#if OSSDEBUG > 1
#define OSS_CTX_DEFZERO(ELEM) _Context_Element ELEM = {NULL, NULL, 0};
#define OSS_CTX_INCOCR(ELEM) ELEM._occurrence++;
#define OSS_CTX_SETOCR(ELEM, OCR) ELEM._occurrence = OCR;
#define OSS_CTX_DEF(ELEM) _Context_Element ELEM;
#define OSS_CTX_SET(ELEM, CTXID) ELEM._id = (_Context_Id *)&_context_id[CTXID];
#define OSS_CTX_POP(OSC, ELEM) OSC->_oss_context_anchor._last = ELEM._parent;
#define OSS_CTX_PUSH(OSC, ELEM) ELEM._parent = OSC->_oss_context_anchor._last;\
	OSC->_oss_context_anchor._last = &ELEM;
#define OSS_CTX_ENTER(OSC, ELEM, CTXID) ELEM._id = (_Context_Id *)&_context_id[CTXID];\
	ELEM._parent = OSC->_oss_context_anchor._last;\
	OSC->_oss_context_anchor._last = &ELEM;
#define OSS_CTX_ANCHOR_SET(ELEM, PDU, CTXID) \
	ELEM._parent = _oss_c->_oss_context_anchor._last;\
	ELEM._id = (_Context_Id *)&_context_id[CTXID];\
	if (!_oss_c->_oss_context_anchor._last)\
	{	_oss_c->_oss_context_anchor._pdu_number = PDU;\
		_oss_c->_oss_context_anchor._pdu_id = ELEM._id; }\
	_oss_c->_oss_context_anchor._last = &ELEM;
#else
#define OSS_CTX_DEFZERO(ELEM)
#define OSS_CTX_INCOCR(ELEM)
#define OSS_CTX_SETOCR(ELEM, OCR)
#define OSS_CTX_DEF(ELEM)
#define OSS_CTX_SET(ELEM, CTXID)
#define OSS_CTX_POP(OSC, ELEM)
#define OSS_CTX_PUSH(OSC, ELEM)
#define OSS_CTX_ENTER(OSC, ELEM, CTXID)
#define OSS_CTX_ANCHOR_SET(PDU, ELEM, CTXID)
#endif
/* Control table object */

class asn_bench_TableType : public OssControlTable {
public:
    static void *internal;
    asn_bench_TableType();
    int destroy(void *data, OssTypeIndex typeindex);
    int copy(void *src, void **dst, OssTypeIndex typeindex);
    int equal(void *data1, void *data2, OssTypeIndex typeindex);
};

asn_bench_TableType::asn_bench_TableType() : OssControlTable(internal) {
}

int asn_bench_TableType::destroy(void *data, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    delete (AsnTicketSales *)data;
	    break;
	default:
	    return oss_call_error(OSS_UNKNOWN_TYPE);
    }
    return 0;
}

int asn_bench_TableType::copy(void *src, void **dst, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    *dst = new AsnTicketSales(*(AsnTicketSales *)src);
	    break;
	default:
	    return oss_call_error(OSS_UNKNOWN_TYPE);
    }
    if (*dst == 0)
	return OSS_NO_MEMORY;
    return 0;
}

int asn_bench_TableType::equal(void *data1, void *data2, OssTypeIndex typeindex) {
    switch (typeindex) {
	case 1:
	    return *(AsnTicketSales *)data1 == *(AsnTicketSales *)data2;
    }
    return 0;
}

static asn_bench_TableType asn_bench_Table;

/* Representation types */

void *AsnVoucher::operator new(size_t size) {
    return ossNewFunc(size);
}

void AsnVoucher::operator delete(void *ptr) {
    asn1Free(ptr);
}

AsnVoucher::AsnVoucher() {
    memset(this, 0, sizeof(AsnVoucher));
}

AsnVoucher::AsnVoucher(const AsnVoucher & that) {
    OSSTRY {
	voucherNumber_field = that.voucherNumber_field;
	summ_field = that.summ_field;
	goodsName_field = that.goodsName_field;
	timeOfSell_field = that.timeOfSell_field;
	status_field = that.status_field;
    } OSSCLEAN(AsnVoucher)
}

AsnVoucher::AsnVoucher(voucherNumber voucherNumber_val, summ summ_val, const goodsName & goodsName_val, 
    const timeOfSell & timeOfSell_val, status status_val) {
    OSSTRY {
	voucherNumber_field = voucherNumber_val;
	summ_field = summ_val;
	goodsName_field = goodsName_val;
	timeOfSell_field = timeOfSell_val;
	status_field = status_val;
    } OSSCLEAN(AsnVoucher)
}

AsnVoucher & AsnVoucher::operator = (const AsnVoucher & that) {
    if (this == &that)
	return *this;
    voucherNumber_field = that.voucherNumber_field;
    summ_field = that.summ_field;
    goodsName_field = that.goodsName_field;
    timeOfSell_field = that.timeOfSell_field;
    status_field = that.status_field;
    return *this;
}

int AsnVoucher::operator == (const AsnVoucher & that) const {
    if (voucherNumber_field != that.voucherNumber_field)
	return 0;
    if (summ_field != that.summ_field)
	return 0;
    if (goodsName_field != that.goodsName_field)
	return 0;
    if (timeOfSell_field != that.timeOfSell_field)
	return 0;
    if (status_field != that.status_field)
	return 0;
    return 1;
}

int AsnVoucher::operator != (const AsnVoucher & that) const {
    return !(operator ==(that));
}

AsnVoucher::voucherNumber & AsnVoucher::get_voucherNumber() {
    return voucherNumber_field;
}

AsnVoucher::voucherNumber AsnVoucher::get_voucherNumber() const {
    return voucherNumber_field;
}

void AsnVoucher::set_voucherNumber(voucherNumber voucherNumber_val) {
    voucherNumber_field = voucherNumber_val;
}

AsnVoucher::summ & AsnVoucher::get_summ() {
    return summ_field;
}

AsnVoucher::summ AsnVoucher::get_summ() const {
    return summ_field;
}

void AsnVoucher::set_summ(summ summ_val) {
    summ_field = summ_val;
}

AsnVoucher::goodsName & AsnVoucher::get_goodsName() {
    return goodsName_field;
}

const AsnVoucher::goodsName & AsnVoucher::get_goodsName() const {
    return goodsName_field;
}

void AsnVoucher::set_goodsName(const goodsName & goodsName_val) {
    goodsName_field = goodsName_val;
}

AsnVoucher::timeOfSell & AsnVoucher::get_timeOfSell() {
    return timeOfSell_field;
}

const AsnVoucher::timeOfSell & AsnVoucher::get_timeOfSell() const {
    return timeOfSell_field;
}

void AsnVoucher::set_timeOfSell(const timeOfSell & timeOfSell_val) {
    timeOfSell_field = timeOfSell_val;
}

AsnVoucher::status & AsnVoucher::get_status() {
    return status_field;
}

AsnVoucher::status AsnVoucher::get_status() const {
    return status_field;
}

void AsnVoucher::set_status(status status_val) {
    status_field = status_val;
}

/* Auxiliary data structures and functions for class __seqof1 */

class __seqof1_member {
public:
    __seqof1_member *next;
    __seqof1::component value;
    void * operator new(size_t size);
    void operator delete(void *ptr);
    __seqof1_member();
    __seqof1_member(const __seqof1::component & val);
};

void *__seqof1_member::operator new(size_t size) {
    return ossNewFunc(size);
}

void __seqof1_member::operator delete(void *ptr) {
    asn1Free(ptr);
}

__seqof1_member::__seqof1_member() {
}

__seqof1_member::__seqof1_member(const __seqof1::component & val) {
    value = val;
}

static void *__seqof1_copy(void *that) {
    return new __seqof1_member(((__seqof1_member *)that)->value);
}

static void __seqof1_destroy(void *that) {
    delete (__seqof1_member *)that;
}

static int __seqof1_compare(void *val1, void *val2) {
    return (((__seqof1_member *)val1)->value == ((__seqof1_member *)val2)->value);
}

/* Constructors */

__seqof1::__seqof1() {
}

__seqof1::__seqof1(const __seqof1 & that) {
    OSSTRY {
	do_copy(that, &__seqof1_copy);
    } OSSCLEAN(__seqof1)
}

/* Destructor */

__seqof1::~__seqof1() {
    do_destroy(&__seqof1_destroy);
}

/* Operators: assignment, equality, inequality */

__seqof1 & __seqof1::operator = (const __seqof1 & that) {
    do_destroy(&__seqof1_destroy);
    do_copy(that, &__seqof1_copy);
    return *this;
}

int __seqof1::operator == (const __seqof1 & that) const {
    return do_compare(that, &__seqof1_compare);
}

int __seqof1::operator != (const __seqof1 & that) const {
    return !do_compare(that, &__seqof1_compare);
}

/* Locate ("At" etc) methods */

__seqof1::component *__seqof1::at(OssIndex pos) {
    return &((__seqof1_member *)pos)->value;
}

const __seqof1::component *__seqof1::at(OssIndex pos) const {
    return &((__seqof1_member *)pos)->value;
}

/* Add ("Insert", "Prepend", "Append" etc) methods */

OssIndex __seqof1::prepend(const component & val) {
    __seqof1_member *newrec = new __seqof1_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_prepend(newrec);
}

OssIndex __seqof1::prepend(__seqof1 *seq) {
    return do_prepend(seq);
}

OssIndex __seqof1::insert_after(OssIndex pos, const component & val) {
    __seqof1_member *newrec = new __seqof1_member(val);
    if (!newrec)
	return OSS_NOINDEX;
    return do_insert_after(pos, newrec);
}

OssIndex __seqof1::insert_after(OssIndex pos, __seqof1 *seq) {
    return do_insert_after(pos, seq);
}

/* Remove methods */

int __seqof1::remove_front() {
    __seqof1_member *extr = (__seqof1_member *)do_extract_front();
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof1_destroy(extr);
    return 0;
}

int __seqof1::remove_after(OssIndex pos) {
    __seqof1_member *extr = (__seqof1_member *)do_extract_after(pos);
    if (!extr)
	return oss_call_error(OSS_COMPONENT_MISSING);
    __seqof1_destroy(extr);
    return 0;
}

/* Extract methods */

__seqof1 *__seqof1::extract_after(OssIndex begin, OssIndex end) {
    return (__seqof1 *)do_extract_after(begin, end);
}

void *AsnTicketSales::operator new(size_t size) {
    return ossNewFunc(size);
}

void AsnTicketSales::operator delete(void *ptr) {
    asn1Free(ptr);
}

AsnTicketSales::AsnTicketSales() {
    memset(this, 0, sizeof(AsnTicketSales));
}

AsnTicketSales::AsnTicketSales(const AsnTicketSales & that) {
    OSSTRY {
	shiftNumber_field = that.shiftNumber_field;
	cashRegister_field = that.cashRegister_field;
	startShift_field = that.startShift_field;
	endShift_field = that.endShift_field;
	vouchers_field = that.vouchers_field;
    } OSSCLEAN(AsnTicketSales)
}

AsnTicketSales::AsnTicketSales(shiftNumber shiftNumber_val, cashRegister cashRegister_val, 
    const startShift & startShift_val, const endShift & endShift_val, const vouchers & vouchers_val) {
    OSSTRY {
	shiftNumber_field = shiftNumber_val;
	cashRegister_field = cashRegister_val;
	startShift_field = startShift_val;
	endShift_field = endShift_val;
	vouchers_field = vouchers_val;
    } OSSCLEAN(AsnTicketSales)
}

AsnTicketSales & AsnTicketSales::operator = (const AsnTicketSales & that) {
    if (this == &that)
	return *this;
    shiftNumber_field = that.shiftNumber_field;
    cashRegister_field = that.cashRegister_field;
    startShift_field = that.startShift_field;
    endShift_field = that.endShift_field;
    vouchers_field = that.vouchers_field;
    return *this;
}

int AsnTicketSales::operator == (const AsnTicketSales & that) const {
    if (shiftNumber_field != that.shiftNumber_field)
	return 0;
    if (cashRegister_field != that.cashRegister_field)
	return 0;
    if (startShift_field != that.startShift_field)
	return 0;
    if (endShift_field != that.endShift_field)
	return 0;
    if (vouchers_field != that.vouchers_field)
	return 0;
    return 1;
}

int AsnTicketSales::operator != (const AsnTicketSales & that) const {
    return !(operator ==(that));
}

AsnTicketSales::shiftNumber & AsnTicketSales::get_shiftNumber() {
    return shiftNumber_field;
}

AsnTicketSales::shiftNumber AsnTicketSales::get_shiftNumber() const {
    return shiftNumber_field;
}

void AsnTicketSales::set_shiftNumber(shiftNumber shiftNumber_val) {
    shiftNumber_field = shiftNumber_val;
}

AsnTicketSales::cashRegister & AsnTicketSales::get_cashRegister() {
    return cashRegister_field;
}

AsnTicketSales::cashRegister AsnTicketSales::get_cashRegister() const {
    return cashRegister_field;
}

void AsnTicketSales::set_cashRegister(cashRegister cashRegister_val) {
    cashRegister_field = cashRegister_val;
}

AsnTicketSales::startShift & AsnTicketSales::get_startShift() {
    return startShift_field;
}

const AsnTicketSales::startShift & AsnTicketSales::get_startShift() const {
    return startShift_field;
}

void AsnTicketSales::set_startShift(const startShift & startShift_val) {
    startShift_field = startShift_val;
}

AsnTicketSales::endShift & AsnTicketSales::get_endShift() {
    return endShift_field;
}

const AsnTicketSales::endShift & AsnTicketSales::get_endShift() const {
    return endShift_field;
}

void AsnTicketSales::set_endShift(const endShift & endShift_val) {
    endShift_field = endShift_val;
}

AsnTicketSales::vouchers & AsnTicketSales::get_vouchers() {
    return vouchers_field;
}

const AsnTicketSales::vouchers & AsnTicketSales::get_vouchers() const {
    return vouchers_field;
}

void AsnTicketSales::set_vouchers(const vouchers & vouchers_val) {
    vouchers_field = vouchers_val;
}

/* Universal PDU class */

asn_bench_PDU::asn_bench_PDU() {
}

void asn_bench_PDU::set_AsnTicketSales(AsnTicketSales & d) {
    index = 1;
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AsnTicketSales *asn_bench_PDU::get_AsnTicketSales() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (index == 1 && !constant)
#else
    if (index == 1)
#endif
	return (AsnTicketSales *)data;
    else
	return 0;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
void asn_bench_PDU::set_const_AsnTicketSales(const AsnTicketSales & d) {
    index = 1;
    data = (void *)&d;
    constant = 1;
}

const AsnTicketSales *asn_bench_PDU::get_const_AsnTicketSales() const {
    if (index == 1)
	return (const AsnTicketSales *)data;
    else
	return 0;
}

#endif
/* Specific PDU classes */

AsnTicketSales_PDU::AsnTicketSales_PDU() {
}

void AsnTicketSales_PDU::set_data(AsnTicketSales & d) {
    data = &d;
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    constant = 0;
#endif
}

AsnTicketSales *AsnTicketSales_PDU::get_data() const {
#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED
    if (constant)
	return 0;
#endif
    return (AsnTicketSales *)data;
}

#ifdef OSS_PREALLOCATED_BUFFER_DECODE_SUPPORTED

void AsnTicketSales_PDU::set_const_data(const AsnTicketSales & d) {
    data = (void *)&d;
    constant = 1;
}

const AsnTicketSales *AsnTicketSales_PDU::get_const_data() const {
    return (const AsnTicketSales *)data;
}

#endif

OssTypeIndex AsnTicketSales_PDU::get_index() const {
    return 1;
}

/* Control object class */

asn_bench_Control::asn_bench_Control() : OssControl(&asn_bench_Table, asn_bench_TableType::internal) {
}

asn_bench_Control::asn_bench_Control(const asn_bench_Control & that) : OssControl(that) {
}


/* ASN.1 data initialization */
/* Local control table initialization */

extern "C" void DLL_ENTRY _oss_run_TOED_on_INTEL_X86_WINDOWS_AND_WINNT(void);

extern "C" {
static void _oss_post_init(struct ossGlobal *world);

/* TOED internal function declarations */

#ifdef OSS_COPY_VALUE
int DLL_ENTRY _CPAsnTest(struct ossGlobal * _g, int pduNum, void * src, void ** pdst);
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
int DLL_ENTRY _CMAsnTest(struct ossGlobal * _g, int _pduNum, void * _odata, void * _cdata);
#endif /* OSS_COMPARE_VALUE */

void DLL_ENTRY _xeAsnTest(struct ossGlobal * _g, int _pdunum, void * _inbuf);
void DLL_ENTRY _xdAsnTest(struct ossGlobal * _g, int * _pdunum, void ** _outbuf);
void DLL_ENTRY _oeAsnTest(OssGlobal * _g, int _pdunum, void * _inbuf);
void * DLL_ENTRY _odAsnTest(OssGlobal * _g, int _pdunum);
static const _oss_xapi_entries_struct _oss_xapi_entries = {
     32
#ifdef OSS_COPY_VALUE
    ,_CPAsnTest
#else
    ,NULL
#endif
#ifdef OSS_COMPARE_VALUE
    ,_CMAsnTest
#else
    ,NULL
#endif
    ,_xeAsnTest
    ,_xdAsnTest
    ,102
    ,NULL
    ,NULL
#if OSS_TOED_API_LEVEL >= 24
    ,NULL
    ,NULL
    ,100
#endif
#if OSS_TOED_API_LEVEL >= 31
    ,100
    ,_oeAsnTest
    ,_odAsnTest
#endif
};

/* Local control table initialization */

static unsigned char _privateFlags[] = {0x5b,0x10};
void DLL_ENTRY_FDEF _ossinit_asn_bench(struct ossGlobal *world) {
    _EncDecGlobals *_oss_c;

    _oss_run_TOED_on_INTEL_X86_WINDOWS_AND_WINNT();
    ossPrivateSetMoreFlags(world, 14, _privateFlags);
    ossLinkBer(world);
    ossLinkOerE(world);
    ossLinkOerD(world);
    ossLinkPer(world);
    if (world) {
        _oss_c = (_EncDecGlobals *)world->encDecVar;
        _oss_c->der = 1;
    }
    ossLinkXer(world);
    ossInitXAPIentries(world, &_oss_xapi_entries);
    _oss_post_init(world);
}

/* TOED internal function declarations */


struct _AsnVoucher {
    OSS_INT32  voucherNumber;
    double  summ;
    OSSC::COssString  goodsName;
    char *  timeOfSell;
    ossBoolean  status;
};

struct _seqof1 {
    struct _seqof1 * next;
    _AsnVoucher  value;
};

struct _AsnTicketSales {
    OSS_INT32  shiftNumber;
    OSS_INT32  cashRegister;
    char *  startShift;
    char *  endShift;
    _seqof1 * vouchers;
};
static void _eAsnTicketSales(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags);
static void _epAsnTicketSales(OssGlobal * _g, void * _inbuf);
static void _exAsnTicketSales(OssGlobal * _g, void * _in_buf);
static void * _dAsnTicketSales(OssGlobal * _g);
static void * _dpAsnTicketSales(OssGlobal * _g);
static void * _dxAsnTicketSales(_Xml_Dec_Env * _env);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void _fAsnTicketSales(OssGlobal * _g, void * _data);
#endif
#ifdef OSSPRINT
static int _pAsnTicketSales(OssGlobal * _g, void * _data);
#endif
static void _eoAsnTicketSales(OssGlobal * _g, void * _data);
static void * _doAsnTicketSales(OssGlobal * _g);
void DLL_ENTRY _emAsnTest(struct ossGlobal * _g, int _pdunum, void * _inbuf);
void DLL_ENTRY _peAsnTest(struct ossGlobal * _g, int _pdunum, void * _inbuf);
void DLL_ENTRY _dmAsnTest(struct ossGlobal * _g, int * _pdunum, void ** _outbuf);
void DLL_ENTRY _pdAsnTest(struct ossGlobal * _g, int * _pdunum, void ** _outbuf);
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
int DLL_ENTRY _fmAsnTest(struct ossGlobal * _g, int _pdunum, void * _data);
#endif
#ifdef OSSPRINT
int DLL_ENTRY _pmAsnTest(struct ossGlobal * _g, int _pdunum, void * _data);
#endif



#ifdef OSS_COPY_VALUE
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
#endif /* OSS_COMPARE_VALUE */

static void (*_Encoders[1])(OssGlobal *, void *, char **, long *, unsigned int) = {
    _eAsnTicketSales
};
static void (*_pEncoders[1])(OssGlobal *, void *) = {
    _epAsnTicketSales
};
static void (*_xEncoders[1])(OssGlobal *, void *) = {
    _exAsnTicketSales
};
static void *(*_Decoders[1])(OssGlobal *) = {
    _dAsnTicketSales
};
static void *(*_pDecoders[1])(OssGlobal *) = {
    _dpAsnTicketSales
};
static void *(*_xDecoders[1])(_Xml_Dec_Env *) = {
    _dxAsnTicketSales
};
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
static void (*_FreePDU[1])(OssGlobal *, void *) = {
    _fAsnTicketSales
};
#endif
#ifdef OSSPRINT
static _print_pdu_ _PrintPDU[1] = {
    { _pAsnTicketSales, (char *)"AsnTicketSales" }
};
#endif

/* TOED internal function implementations */

static unsigned char _v_ex_str12[] = "status";
static unsigned char _v_ex_str3[] = "cashRegister";
static unsigned char _v_ex_str7[] = "AsnVoucher";
static unsigned char _v_ex_str10[] = "goodsName";
static unsigned char _v_ex_str5[] = "endShift";
static unsigned char _v_ex_str4[] = "startShift";
static unsigned char _v_ex_str2[] = "shiftNumber";
static unsigned char _v_ex_str8[] = "voucherNumber";
static unsigned char _v_ex_str6[] = "vouchers";
static unsigned char _v_ex_str1[] = "AsnTicketSales";
static unsigned char _v_ex_str9[] = "summ";
static unsigned char _v_ex_str11[] = "timeOfSell";

#if OSSDEBUG > 1
static const _Context_Id _context_id[] = {
    {(char *)_v_ex_str1, (char *)"SEQUENCE", _sequence_type},
    {(char *)_v_ex_str2, (char *)"INTEGER", _integer_type},
    {(char *)_v_ex_str3, (char *)"INTEGER", _integer_type},
    {(char *)_v_ex_str4, (char *)"Character String", _charstring_type},
    {(char *)_v_ex_str5, (char *)"Character String", _charstring_type},
    {(char *)_v_ex_str6, (char *)"SEQUENCE OF", _sequence_of_type},
    {NULL, (char *)_v_ex_str7, _sequence_type},
    {(char *)_v_ex_str8, (char *)"INTEGER", _integer_type},
    {(char *)_v_ex_str9, (char *)"REAL", _real_type},
    {(char *)_v_ex_str10, (char *)"Character String", _charstring_type},
    {(char *)_v_ex_str11, (char *)"Character String", _charstring_type},
    {(char *)_v_ex_str12, (char *)"BOOLEAN", _boolean_type}
};
#endif


static const struct st_PER_String_Data _chars[1] = {
    { NULL, 1, 0, UINT_MAX, 0x18788 }
};
static void _eoAsnTicketSales(OssGlobal * _g, void * _data)
{
    _AsnTicketSales  * _val_addr = (_AsnTicketSales  *)_data;
    OSS_CTX_DEFZERO(_element0)
#if OSSDEBUG > 1
    _EncDecGlobals * _oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif

    OSS_CTX_ANCHOR_SET(_element0, 1, 0)
    {
	OSS_CTX_DEF(_element1)
	unsigned long _len1;

	OSS_CTX_SETOCR(_element1, 0)
	OSS_CTX_ENTER(_oss_c, _element1, 1)
	_oss_oenc_int(_g, _val_addr->shiftNumber);
	OSS_CTX_SET(_element1, 2)
	_oss_oenc_int(_g, _val_addr->cashRegister);
	OSS_CTX_SET(_element1, 3)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (!_val_addr->startShift)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_len1 = (unsigned long)strlen(_val_addr->startShift);
	_oss_oenc_octet_length(_g, _len1);
	_oss_oenc_append_bytes(_g, (unsigned char *)_val_addr->startShift, _len1);
	OSS_CTX_SET(_element1, 4)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (!_val_addr->endShift)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_len1 = (unsigned long)strlen(_val_addr->endShift);
	_oss_oenc_octet_length(_g, _len1);
	_oss_oenc_append_bytes(_g, (unsigned char *)_val_addr->endShift, _len1);
	OSS_CTX_SET(_element1, 5)
	{
	    _seqof1 * _otemp1;
	    unsigned int _oidx1 = 0;
	    OSS_CTX_DEF(_element2)

	    for (_otemp1 = _val_addr->vouchers; _otemp1; _otemp1 = _otemp1->next, _oidx1++)
		;
	    _oss_oenc_uint(_g, _oidx1);
	    OSS_CTX_SETOCR(_element2, 0)
	    OSS_CTX_ENTER(_oss_c, _element2, 6)
	    for (_otemp1 = _val_addr->vouchers; _otemp1; _otemp1 = _otemp1->next) {
		OSS_CTX_INCOCR(_element2)
		{
		    OSS_CTX_DEF(_element3)
		    unsigned long _len3;

		    OSS_CTX_SETOCR(_element3, 0)
		    OSS_CTX_ENTER(_oss_c, _element3, 7)
		    _oss_oenc_int(_g, _otemp1->value.voucherNumber);
		    OSS_CTX_SET(_element3, 8)
		    _oss_oenc_real(_g, _otemp1->value.summ);
		    OSS_CTX_SET(_element3, 9)
		    _oss_oenc_octet_length(_g, _otemp1->value.goodsName.length);
		    _oss_oenc_append_bytes(_g, (unsigned char *)_otemp1->value.goodsName.value, _otemp1->value.goodsName.length);
		    OSS_CTX_SET(_element3, 10)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (!_otemp1->value.timeOfSell)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _len3 = (unsigned long)strlen(_otemp1->value.timeOfSell);
		    _oss_oenc_octet_length(_g, _len3);
		    _oss_oenc_append_bytes(_g, (unsigned char *)_otemp1->value.timeOfSell, _len3);
		    OSS_CTX_SET(_element3, 11)
		    _oss_oenc_append_byte(_g, _otemp1->value.status ? 0xFF : 0);
		    OSS_CTX_POP(_oss_c, _element3)
		}
	    }
	    OSS_CTX_POP(_oss_c, _element2)
	}
	OSS_CTX_POP(_oss_c, _element1)
    }
    OSS_CTX_POP(_oss_c, _element0)
}

static void * _doAsnTicketSales(OssGlobal * _g)
{
    OSS_CTX_DEFZERO(_element0)
#if !defined(OSS_NO_NESTING_CONTROL) || OSSDEBUG > 1
    _EncDecGlobals * _oss_c = (_EncDecGlobals *)_g->encDecVar;
#endif
    _AsnTicketSales  * _out_data0;

    OSS_CTX_ANCHOR_SET(_element0, 1, 0)
    _out_data0 = (_AsnTicketSales  *)_oss_dec_const_alloc(_g, sizeof(_AsnTicketSales ));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CTX_DEF(_element1)

	OSS_CTX_SETOCR(_element1, 0)
	OSS_CTX_PUSH(_oss_c, _element1)
	OSS_CTX_SET(_element1, 1)
	_out_data0->shiftNumber = _oss_odec_int(_g);
	OSS_CTX_SET(_element1, 2)
	_out_data0->cashRegister = _oss_odec_int(_g);
	OSS_CTX_SET(_element1, 3)
	{
	    unsigned int _len1 = _oss_odec_length(_g);

	    _out_data0->startShift = (char * )_oss_dec_getmem_internal(_g, _len1 + 1);
	    _oss_odec_read_octets(_g, _out_data0->startShift, _len1);
	    (_out_data0->startShift)[_len1] = 0;
	}
	OSS_CTX_SET(_element1, 4)
	{
	    unsigned int _len1 = _oss_odec_length(_g);

	    _out_data0->endShift = (char * )_oss_dec_getmem_internal(_g, _len1 + 1);
	    _oss_odec_read_octets(_g, _out_data0->endShift, _len1);
	    (_out_data0->endShift)[_len1] = 0;
	}
	OSS_CTX_SET(_element1, 5)
	{
	    _seqof1 * _out_data1;

#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		    _oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	    {
		_seqof1 * _head1;
		unsigned int _count1 = _oss_odec_uint(_g);
		OSS_CTX_DEF(_element2)

		OSS_CTX_SETOCR(_element2, 0)
		OSS_CTX_ENTER(_oss_c, _element2, 6)
		if (_count1 > 0) {
		    _seqof1 * _cur1;

		    OSS_CTX_INCOCR(_element2)
		    _cur1 = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1 ));
		    _head1 = _cur1;
		    for (;;) {
			_seqof1 * _temp1 = _cur1;

#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
				++_oss_c->reserved.fields.ext->seqSetNestingCounter >
				_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
			{
			    OSS_CTX_DEF(_element3)

			    OSS_CTX_SETOCR(_element3, 0)
			    OSS_CTX_PUSH(_oss_c, _element3)
			    OSS_CTX_SET(_element3, 7)
			    _cur1->value.voucherNumber = _oss_odec_int(_g);
			    OSS_CTX_SET(_element3, 8)
			    _cur1->value.summ = _oss_odec_real_double(_g);
			    OSS_CTX_SET(_element3, 9)
			    _cur1->value.goodsName.length = _oss_odec_string_unbounded(_g, (char **)(&_cur1->value.goodsName.value));
			    OSS_CTX_SET(_element3, 10)
			    {
				unsigned int _len3 = _oss_odec_length(_g);

				_cur1->value.timeOfSell = (char * )_oss_dec_getmem_internal(_g, _len3 + 1);
				_oss_odec_read_octets(_g, _cur1->value.timeOfSell, _len3);
				(_cur1->value.timeOfSell)[_len3] = 0;
			    }
			    OSS_CTX_SET(_element3, 11)
			    _cur1->value.status = _oss_odec_bool(_g);
			    OSS_CTX_POP(_oss_c, _element3)
			}
#ifndef OSS_NO_NESTING_CONTROL
			if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
			if (--_count1 == 0)
			    break;
			OSS_CTX_INCOCR(_element2)
			_cur1 = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1 ));
			_temp1->next = _cur1;
		    }
		    _cur1->next = NULL;
		} else
		    _head1 = NULL;
		_out_data1 = _head1;
		OSS_CTX_POP(_oss_c, _element2)
	    }
#ifndef OSS_NO_NESTING_CONTROL
	    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
		_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	    _out_data0->vouchers = _out_data1;
	}
	OSS_CTX_POP(_oss_c, _element1)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CTX_POP(_oss_c, _element0)

    return _out_data0;
}

void DLL_ENTRY_FDEF _oeAsnTest(OssGlobal * _g, int _pdunum, void * _inbuf)
{
    _EncDecGlobals * _oss_c = (_EncDecGlobals*)_g->encDecVar;

#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_pre(_g, _pdunum, _inbuf, NULL, _oss_c->_oss_outbufpos, OSS_outbuf_getlen(_oss_c));
#else
    _oss_c->_oss_err_msg = NULL;
#endif
#if OSSDEBUG > 0
    _oss_c->_oss_context_anchor._pdu_number = 0;
#endif
    if (_g->encRules == OSS_COER)
	_oss_toed_error(_g, _toed_rules_not_supp_err, "CANONICAL OER");
    _pdunum = _pdunum;	/* to avoid C-compilation warning */
    _eoAsnTicketSales(_g, (_AsnTicketSales  *)_inbuf);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_post(_g, 0, _oss_c->_oss_outbufpos, OSS_outbuf_getlen(_oss_c));
#endif
}

void * DLL_ENTRY_FDEF _odAsnTest(OssGlobal * _g, int _pdunum)
{
    _EncDecGlobals * _oss_c = (_EncDecGlobals *)_g->encDecVar;
    void * _outbuf;

#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_pre(_g, _oss_c->_oss_inbufpos, OSS_inbuf_getlen(_oss_c), NULL);
#else
    _oss_c->_oss_err_msg = NULL;
#endif
#if OSSDEBUG > 0
    _oss_c->_oss_context_anchor._pdu_number = 0;
#endif
    if (_g->encRules == OSS_COER)
	_oss_toed_error(_g, _toed_rules_not_supp_err, "CANONICAL OER");
    _pdunum = _pdunum;	/* to avoid C-compilation warning */
    _outbuf = _doAsnTicketSales(_g);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags) {
	void * _tmp_out = _outbuf;
	_oss_db_d_post(_g, 0, _pdunum, &_tmp_out);
    }
#endif
    return _outbuf;
}

static void _eAsnTicketSales(OssGlobal * _g, void * _inbuf, char ** _outbuf, long * _outlen, unsigned int _flags)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AsnTicketSales	*_in_data;
    char *_out_buf;
    char **_out_pos = &_out_buf;
    long _out_len;
    long _data_len = 0;
    ossBoolean _constructed = FALSE;
    OSS_CNTX_INITZERO

    _in_data = (_AsnTicketSales *) _inbuf;
    if (!_oss_c->_buffer_provided) *_outbuf = NULL;
    _out_buf = *_outbuf;
    _out_len = _oss_c->_oss_outbuflen = (_oss_c->_buffer_provided) ? *_outlen : 0;
    _out_buf += _out_len;
    OSS_CNTX_ANCHOR_SET(1,0)
    {
	long _total_len = 0;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 5)
	{
	    _seqof1 * _temp;
	    unsigned long count;
	    unsigned long _lindex;
	    long _total_len = 0;
	    OSS_UINT32 _sp;
	    void **_st = _oss_load_enc_stack(_g, &_sp);
	    OSS_CNTX_NEW(_oss_c, 6)
	    for (_temp = _in_data->vouchers, count = 0; _temp; _temp = _temp->next) {
		OSS_CNTX_SETOCC(count + 1)
		if (_sp == _MEM_ARRAY_SIZE) { _st = _oss_increment_enc_stack(_g); _sp = 0; }
		_st[_sp++] = _temp;
		count++;
	    }
	    for (_lindex = 0; _lindex < count; _lindex++) {
		OSS_CNTX_SETOCC(count - _lindex)
		_temp = (_seqof1 *)_st[--_sp];
		if (!_sp) { _st = _oss_decrement_enc_stack(_g); _sp = _MEM_ARRAY_SIZE; }
		{
		    long _total_len = 0;
		    OSS_CNTX_INIT

		    OSS_CNTX_PUSH(_oss_c, 11)
		    _data_len = _oss_encd_bool_tl(_g, _out_pos, &_out_len, 0x1, _temp->value.status);
		    _total_len += _data_len;
		    OSS_CNTX_SET(10)
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_temp->value.timeOfSell == NULL)
			_oss_enc_error(_g, _bad_pointer, 0L);
#endif
		    _data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _temp->value.timeOfSell, -1, 1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x37 : 0x17);
		    _total_len += _data_len;
		    OSS_CNTX_SET(9)
		    _data_len = _oss_encd_utf8unbound_ia(_g, _out_pos, &_out_len, (unsigned char *)_temp->value.goodsName.value, _temp->value.goodsName.length, -1);
		    if (_data_len < 0) {
			_constructed = TRUE;
			_data_len = -_data_len;
		    } else
			_constructed = FALSE;
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x2C : 0xC);
		    _total_len += _data_len;
		    OSS_CNTX_SET(8)
		    _data_len = _oss_encd_real(_g, _out_pos, &_out_len, _temp->value.summ);
		    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x9);
		    _total_len += _data_len;
		    OSS_CNTX_SET(7)
		    _data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _temp->value.voucherNumber, 0x2);
		    _total_len += _data_len;
		    OSS_CNTX_POP(_oss_c)
		    _data_len = _total_len;
		}
		_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
		_total_len += _data_len;
	    }
	    _oss_save_enc_stack(_g, _sp);
	    OSS_CNTX_POP(_oss_c)
	    _data_len = _total_len;
	}
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
	_total_len += _data_len;
	OSS_CNTX_SET(4)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->endShift == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->endShift, -1, 1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x37 : 0x17);
	_total_len += _data_len;
	OSS_CNTX_SET(3)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->startShift == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	_data_len = _oss_encd_untime(_g, _out_pos, &_out_len, _in_data->startShift, -1, 1);
	if (_data_len < 0) {
	    _constructed = TRUE;
	    _data_len = -_data_len;
	} else
	    _constructed = FALSE;
	_data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, _constructed ? 0x37 : 0x17);
	_total_len += _data_len;
	OSS_CNTX_SET(2)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->cashRegister, 0x2);
	_total_len += _data_len;
	OSS_CNTX_SET(1)
	_data_len = _oss_encd_int_tl(_g, _out_pos, &_out_len, _in_data->shiftNumber, 0x2);
	_total_len += _data_len;
	OSS_CNTX_POP(_oss_c)
	_data_len = _total_len;
    }
    _data_len += _oss_encd_tag_length(_g, _out_pos, &_out_len, _data_len, 0x30);
    if (!_oss_c->_buffer_provided)
	_oss_set_outmem_d(_g, _out_len, _outlen, _outbuf);
    else {
	if (_flags & FRONT_ALIGN)
	    memmove(*_outbuf, *_out_pos, (size_t) _data_len);
	else
	    *_outbuf = *_out_pos;
	*_outlen = _data_len;
    }

    OSS_CNTX_POP(_oss_c)
}

static void _epAsnTicketSales(OssGlobal * _g, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AsnTicketSales	*_in_data;
    OSS_CNTX_INITZERO

    _in_data = (_AsnTicketSales *) _inbuf;
    OSS_CNTX_ANCHOR_SET(1,0)
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 1)
	_oss_penc_unconstr_int_l(_g, _in_data->shiftNumber);
	OSS_CNTX_SET(2)
	_oss_penc_unconstr_int_l(_g, _in_data->cashRegister);
	OSS_CNTX_SET(3)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->startShift == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	if(!(_g->encodingFlags & NOCONSTRAIN))
	    _oss_check_nullterm_time(_g, _in_data->startShift, 1);
	_oss_penc_kmstr(_g, _in_data->startShift, (unsigned long)strlen(_in_data->startShift), _chars + 0, 0);
	OSS_CNTX_SET(4)
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_in_data->endShift == NULL)
	    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
	if(!(_g->encodingFlags & NOCONSTRAIN))
	    _oss_check_nullterm_time(_g, _in_data->endShift, 1);
	_oss_penc_kmstr(_g, _in_data->endShift, (unsigned long)strlen(_in_data->endShift), _chars + 0, 0);
	OSS_CNTX_SET(5)
	{
	    _seqof1 * _temp;
	    unsigned int _fragm_cnt;
	    unsigned int _cnt;
	    int _ext;
	    OSS_CNTX_INIT

	    for (_cnt = 0, _temp = _in_data->vouchers; _temp; _temp = _temp->next)
		++_cnt;

	    OSS_CNTX_PUSH(_oss_c, 6)
	    _ext = (_cnt >= 16384) ? 2 : 0;
	    for (_temp = _in_data->vouchers;; _cnt -= _fragm_cnt) {
		unsigned int _idx;

#if OSS_TOED_API_LEVEL >= 27
		_fragm_cnt = _oss_penc_lfrag(_g, _cnt);
#else
		_fragm_cnt = (unsigned int)_oss_penc_length_l(_g, _cnt, 0, 0, 0);
#endif
		for (_idx = 0; _idx < _fragm_cnt; ++_idx, _temp = _temp->next) {
		    OSS_CNTX_INCOCC
		    {
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 7)
			_oss_penc_unconstr_int_l(_g, _temp->value.voucherNumber);
			OSS_CNTX_SET(8)
			_oss_penc_real(_g, _temp->value.summ);
			OSS_CNTX_SET(9)
			_oss_penc_nkmstr_l(_g, _temp->value.goodsName.value, _temp->value.goodsName.length);
			OSS_CNTX_SET(10)
#ifndef OSS_DO_NOT_CHECK_POINTERS
			if (_temp->value.timeOfSell == NULL)
			    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
			if(!(_g->encodingFlags & NOCONSTRAIN))
			    _oss_check_nullterm_time(_g, _temp->value.timeOfSell, 1);
			_oss_penc_kmstr(_g, _temp->value.timeOfSell, (unsigned long)strlen(_temp->value.timeOfSell), _chars + 0, 0);
			OSS_CNTX_SET(11)
			_oss_append_1bit_unaligned(_g, (unsigned char)((_temp->value.status) ? 0x80 : 0x00) );
			OSS_CNTX_POP(_oss_c)
		    }
		}
		if (_cnt == _fragm_cnt) {
		    if ((_ext & 2) && (_fragm_cnt & 0x3FFF) == 0)
			_oss_append_8bit_aligned(_g, 0);
		    break;
		}
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	OSS_CNTX_POP(_oss_c)
    }
    OSS_CNTX_POP(_oss_c)
}

static void _exAsnTicketSales(OssGlobal * _g, void * _in_buf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AsnTicketSales * _in_data;
    OSS_CNTX_INITZERO

    _in_data = (_AsnTicketSales *)_in_buf;
    OSS_CNTX_ANCHOR_SET(1,0)
    {
	_oss_tex_open_tagN(_g, (char *)_v_ex_str1, 14);
	{
	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 1)
	    {
		_oss_tex_indent_dlt(_g, 2);
		_oss_tex_open_tagN(_g, (char *)_v_ex_str2, 11);
		_oss_tex_lint(_g, (long)(*_in_data).shiftNumber);
		_oss_tex_close_tagN(_g, (char *)_v_ex_str2, 11);
		((_EncDecGlobals*)_g->encDecVar)->reserved.fields.ext->_xee->indent -= 2;
	    }
	    OSS_CNTX_SET(2)
	    {
		_oss_tex_indent_dlt(_g, 2);
		_oss_tex_open_tagN(_g, (char *)_v_ex_str3, 12);
		_oss_tex_lint(_g, (long)(*_in_data).cashRegister);
		_oss_tex_close_tagN(_g, (char *)_v_ex_str3, 12);
		((_EncDecGlobals*)_g->encDecVar)->reserved.fields.ext->_xee->indent -= 2;
	    }
	    OSS_CNTX_SET(3)
	    {
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (!(*_in_data).startShift)
		    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
		{
		    size_t _hasVal1 = strlen((*_in_data).startShift);

		    _oss_tex_indent_dlt(_g, 2);
		    if (!_hasVal1)
			_oss_tex_empty_or_id_tagN(_g, (char *)_v_ex_str4, 10);
		    else
			_oss_tex_open_tagN(_g, (char *)_v_ex_str4, 10);
		    if (_hasVal1) {
			_oss_tex_ntime(_g, (*_in_data).startShift, _hasVal1, TRUE);
			_oss_tex_close_tagN(_g, (char *)_v_ex_str4, 10);
		    }
		    ((_EncDecGlobals*)_g->encDecVar)->reserved.fields.ext->_xee->indent -= 2;
		}
	    }
	    OSS_CNTX_SET(4)
	    {
#ifndef OSS_DO_NOT_CHECK_POINTERS
		if (!(*_in_data).endShift)
		    _oss_enc_error(_g, _bad_pointer, 0L);
#endif
		{
		    size_t _hasVal1 = strlen((*_in_data).endShift);

		    _oss_tex_indent_dlt(_g, 2);
		    if (!_hasVal1)
			_oss_tex_empty_or_id_tagN(_g, (char *)_v_ex_str5, 8);
		    else
			_oss_tex_open_tagN(_g, (char *)_v_ex_str5, 8);
		    if (_hasVal1) {
			_oss_tex_ntime(_g, (*_in_data).endShift, _hasVal1, TRUE);
			_oss_tex_close_tagN(_g, (char *)_v_ex_str5, 8);
		    }
		    ((_EncDecGlobals*)_g->encDecVar)->reserved.fields.ext->_xee->indent -= 2;
		}
	    }
	    OSS_CNTX_SET(5)
	    {
		_oss_tex_indent_dlt(_g, 2);
		if (!(*_in_data).vouchers)
		    _oss_tex_empty_or_id_tagN(_g, (char *)_v_ex_str6, 8);
		else
		    _oss_tex_open_tagN(_g, (char *)_v_ex_str6, 8);
		if ((*_in_data).vouchers) {
		    _seqof1  *_tmp1 = (*_in_data).vouchers;
		    OSS_CNTX_INITZERO

		    OSS_CNTX_PUSH(_oss_c, 6)
		    for (_tmp1 = (*_in_data).vouchers; _tmp1; _tmp1 = _tmp1->next) {
			OSS_CNTX_INCOCC
			{
			    _oss_tex_indent_dlt(_g, 2);
			    _oss_tex_open_tagN(_g, (char *)_v_ex_str7, 10);
			    {
				OSS_CNTX_INIT

				OSS_CNTX_PUSH(_oss_c, 7)
				{
				    _oss_tex_indent_dlt(_g, 2);
				    _oss_tex_open_tagN(_g, (char *)_v_ex_str8, 13);
				    _oss_tex_lint(_g, (long)(_tmp1->value).voucherNumber);
				    _oss_tex_close_tagN(_g, (char *)_v_ex_str8, 13);
				    ((_EncDecGlobals*)_g->encDecVar)->reserved.fields.ext->_xee->indent -= 2;
				}
				OSS_CNTX_SET(8)
				{
				    _oss_tex_indent_dlt(_g, 2);
				    _oss_tex_open_tagN(_g, (char *)_v_ex_str9, 4);
				    _oss_tex_dreal(_g, (_tmp1->value).summ);
				    _oss_tex_close_tagN(_g, (char *)_v_ex_str9, 4);
				    ((_EncDecGlobals*)_g->encDecVar)->reserved.fields.ext->_xee->indent -= 2;
				}
				OSS_CNTX_SET(9)
				{
				    _oss_tex_indent_dlt(_g, 2);
				    if (!((_tmp1->value).goodsName).length)
					_oss_tex_empty_or_id_tagN(_g, (char *)_v_ex_str10, 9);
				    else
					_oss_tex_open_tagN(_g, (char *)_v_ex_str10, 9);
				    if (((_tmp1->value).goodsName).length) {
					_oss_tex_format_char(_g, (unsigned char*)((_tmp1->value).goodsName).value, ((_tmp1->value).goodsName).length);
					_oss_tex_close_tagN(_g, (char *)_v_ex_str10, 9);
				    }
				    ((_EncDecGlobals*)_g->encDecVar)->reserved.fields.ext->_xee->indent -= 2;
				}
				OSS_CNTX_SET(10)
				{
#ifndef OSS_DO_NOT_CHECK_POINTERS
				    if (!(_tmp1->value).timeOfSell)
					_oss_enc_error(_g, _bad_pointer, 0L);
#endif
				    {
					size_t _hasVal3 = strlen((_tmp1->value).timeOfSell);

					_oss_tex_indent_dlt(_g, 2);
					if (!_hasVal3)
					    _oss_tex_empty_or_id_tagN(_g, (char *)_v_ex_str11, 10);
					else
					    _oss_tex_open_tagN(_g, (char *)_v_ex_str11, 10);
					if (_hasVal3) {
					    _oss_tex_ntime(_g, (_tmp1->value).timeOfSell, _hasVal3, TRUE);
					    _oss_tex_close_tagN(_g, (char *)_v_ex_str11, 10);
					}
					((_EncDecGlobals*)_g->encDecVar)->reserved.fields.ext->_xee->indent -= 2;
				    }
				}
				OSS_CNTX_SET(11)
				{
				    ossBoolean * _src3 = &((_tmp1->value).status);

				    _oss_tex_indent_dlt(_g, 2);
				    _oss_tex_open_tagN(_g, (char *)_v_ex_str12, 6);
				    _oss_tex_format_enum(_g, (char*)(*_src3 ? "true" : "false"), 0);
				    _oss_tex_close_tagN(_g, (char *)_v_ex_str12, 6);
				    ((_EncDecGlobals*)_g->encDecVar)->reserved.fields.ext->_xee->indent -= 2;
				}
				OSS_CNTX_POP(_oss_c)
			    }
			    _oss_tex_indent(_g);
			    _oss_tex_close_tagN(_g, (char *)_v_ex_str7, 10);
			    ((_EncDecGlobals*)_g->encDecVar)->reserved.fields.ext->_xee->indent -= 2;
			}
		    }
		    OSS_CNTX_POP(_oss_c)
		    _oss_tex_indent(_g);
		    _oss_tex_close_tagN(_g, (char *)_v_ex_str6, 8);
		}
		((_EncDecGlobals*)_g->encDecVar)->reserved.fields.ext->_xee->indent -= 2;
	    }
	    OSS_CNTX_POP(_oss_c)
	}
	_oss_tex_indent(_g);
	_oss_tex_close_tagN(_g, (char *)_v_ex_str1, 14);
    }
    OSS_CNTX_POP(_oss_c)
}

void DLL_ENTRY_FDEF _emAsnTest(struct ossGlobal * _g, int _pdunum, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    char **_outbuf = &_oss_c->_oss_outbufpos;
    long *_outlen = &_oss_c->_oss_outbuflen;
    unsigned int _flags = _g->encodingFlags;
    _oss_c->_oss_context_anchor._state = _encoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_pre(_g, _pdunum, _inbuf, NULL, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    if (_pdunum < 1 || _pdunum > 1)
	_oss_enc_error(_g, _pdu_range, _pdunum);
    else
	_Encoders[_pdunum - 1](_g, _inbuf, _outbuf, _outlen, _flags);
#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_post(_g, 0, *_outbuf, *_outlen);
#endif
}

void DLL_ENTRY_FDEF _peAsnTest(struct ossGlobal * _g, int _pdunum, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _oss_c->_oss_context_anchor._state = _encoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_pre(_g, _pdunum, _inbuf, NULL, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    if (_g->encRules == OSS_PER_ALIGNED)
	_oss_c->_aligned = 1;
    else
	_oss_toed_error(_g, _toed_rules_not_supp_err, "UNALIGNED PER");

    _pdunum = _pdunum;	/* to avoid C-compilation warning */
    _pEncoders[0](_g, _inbuf);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_post(_g, 0, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#endif
}

void DLL_ENTRY_FDEF _xeAsnTest(struct ossGlobal * _g, int _pdunum, void * _inbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _oss_c->_oss_context_anchor._state = _encoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_pre(_g, _pdunum, _inbuf, NULL, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    if (_g->encRules == OSS_CXER)
	_oss_toed_error(_g, _toed_rules_not_supp_err, "CANONICAL XER");
    else
	_oss_c->_cxer = 0;
    _oss_tex_prolog(_g);
    _pdunum = _pdunum;	/* to avoid C-compilation warning */
    _xEncoders[0](_g, _inbuf);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_e_post(_g, 0, _oss_c->_oss_outbufpos, _oss_c->_oss_outbuflen);
#endif
}

static void * _dAsnTicketSales(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AsnTicketSales *_out_data;
    char *_bufpos = _oss_c->_oss_inbufpos;
    long _buflen = _oss_c->_oss_inbuflen;
    long _data_length;
    unsigned int _data_tag;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(1,0)
    _out_data = (_AsnTicketSales *)_oss_dec_const_alloc(_g, sizeof(_AsnTicketSales));
    _oss_c->_tag_decoded = FALSE;
    if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	_buflen -= 2;
	_bufpos += 2;
    } else
	_data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
    _data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	long _total_len = _data_length;
	char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 1)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->shiftNumber = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_SET(2)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
	_data_tag = 0x2;
	_out_data->cashRegister = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
	OSS_CNTX_SET(3)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 23 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x17);
	_data_tag = 0x17;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->startShift, -1, 1);
	OSS_CNTX_SET(4)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 23 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x17);
	_data_tag = 0x17;
	_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_out_data->endShift, -1, 1);
	OSS_CNTX_SET(5)
	if (_buflen >= 2 && (unsigned char)_bufpos[0] == 48 && (_data_length = (signed char)_bufpos[1]) - 1 >= 0) {
	    _buflen -= 2;
	    _bufpos += 2;
	} else
	    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x10);
	_data_tag = 0x10;
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _seqof1 * _head = NULL;
	    _seqof1 * _cur;
	    long _total_len = _data_length;
	    char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
#if OSSDEBUG > 1
	    unsigned long count = 0;
#endif
	    OSS_CNTX_INIT

	    do {
		OSS_CNTX_PUSH(_oss_c, 6)
		if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		    if (_bufpos > _end_pos)
			_oss_dec_error(_g, _inconsis_len, 0L);
#endif
		    break;
		}
		if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
		    _buflen--;
		    _oss_c->_bitpos = _bufpos[0] & 0x20;
		    _data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
		    _bufpos++;
		} else
		    if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			if (_oss_dec_length(_g, &_bufpos, &_buflen))
			    _oss_dec_error(_g, _non_std_eoc, 0L);
			_oss_c->_tag_decoded = FALSE;
			break;
		    }
		_oss_c->_tag_decoded = TRUE;
		_cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
		_head = _cur;
		for (;;) {
		    _seqof1 * _temp = _cur;
#if OSSDEBUG > 1
		    count++;
#endif
		    if (_data_tag != 0x10)
			_oss_dec_error(_g, _tag_mismatch, _data_tag | 0x100000);
		    OSS_CNTX_SETOCC(count)
		    _oss_c->_tag_decoded = FALSE;
		    if (_buflen >= 1 && (_data_length = (unsigned char)_bufpos[0]) < 0x80) {
			_buflen--;
			_bufpos++;
		    } else
			_data_length = _oss_dec_length(_g, &_bufpos, &_buflen);
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			long _total_len = _data_length;
			char *_end_pos = _total_len < 0 ? (char *)OSS_PTR_MAX : _bufpos + _total_len;
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 7)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 2 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x2);
			_data_tag = 0x2;
			_temp->value.voucherNumber = _oss_dec_iint(_g, &_bufpos, &_buflen, _data_length);
			OSS_CNTX_SET(8)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 9 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x9);
			_data_tag = 0x9;
			_oss_dec_real(_g, &_bufpos, &_buflen, _data_length, &_temp->value.summ);
			OSS_CNTX_SET(9)
			if (_buflen >= 2 && ((unsigned char)_bufpos[0] & 0xDF) == 12 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _oss_c->_bitpos = _bufpos[0] & 0x20;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0xC);
			_data_tag = 0xC;
			if(_data_length) {
			    _temp->value.goodsName.length = _oss_dec_utf8unbound_ia(_g, &_bufpos, &_buflen, _data_length, &_temp->value.goodsName.value, 0);
			} else {
			    _temp->value.goodsName.length = 0;
			    _temp->value.goodsName.value = NULL;
			}
			OSS_CNTX_SET(10)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 23 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x17);
			_data_tag = 0x17;
			_oss_dec_untime(_g, &_bufpos, &_buflen, _data_length, &_temp->value.timeOfSell, -1, 1);
			OSS_CNTX_SET(11)
			if (_buflen >= 2 && (unsigned char)_bufpos[0] == 1 && (_data_length = (unsigned char)_bufpos[1]) < 0x80) {
			    _buflen -= 2;
			    _bufpos += 2;
			} else
			    _data_length = _oss_dec_tag_length(_g, &_bufpos, &_buflen, 0x1);
			_data_tag = 0x1;
			_temp->value.status = _oss_dec_bool(_g, &_bufpos, &_buflen, _data_length);
			OSS_CNTX_POP(_oss_c)
			if (_bufpos != _end_pos) {
			    if (_total_len < 0) {
				if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
				    _buflen--;
				    _bufpos++;
				} else
				    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

				if (_data_tag)
				    _oss_dec_error(_g, _expec_eoc, 0L);
				if (_oss_dec_length(_g, &_bufpos, &_buflen))
				    _oss_dec_error(_g, _non_std_eoc, 0L);
				_oss_c->_tag_decoded = FALSE;
			    } else
				_oss_dec_error(_g, _inconsis_len, 0L);
			}
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    if (_bufpos >= _end_pos) {
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_bufpos > _end_pos)
			    _oss_dec_error(_g, _inconsis_len, 0L);
#endif
			break;
		    }
		    if (_buflen >= 1 && _bufpos[0] && ((_bufpos[0]+1) & 0x1F)) {
			_buflen--;
			_oss_c->_bitpos = _bufpos[0] & 0x20;
			_data_tag = (_bufpos[0] & 0x1F) + (((unsigned int)(_bufpos[0] & 0xC0)) << 8);
			_bufpos++;
		    } else
			if ((_data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen)) == 0 && _total_len < 0) {
			    if (_oss_dec_length(_g, &_bufpos, &_buflen))
				_oss_dec_error(_g, _non_std_eoc, 0L);
			    _oss_c->_tag_decoded = FALSE;
			    break;
			}
		    _oss_c->_tag_decoded = TRUE;
		    _cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
		    _temp->next = _cur;
		}
		_cur->next = NULL;
	    } while (0);
	    _out_data->vouchers = _head;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
	if (_bufpos != _end_pos) {
	    if (_total_len < 0) {
		if (_buflen >= 1 && (_data_tag = _bufpos[0]) == 0) {
		    _buflen--;
		    _bufpos++;
		} else
		    _data_tag = _oss_dec_tag(_g, &_bufpos, &_buflen);

		if (_data_tag)
		    _oss_dec_error(_g, _expec_eoc, 0L);
		if (_oss_dec_length(_g, &_bufpos, &_buflen))
		    _oss_dec_error(_g, _non_std_eoc, 0L);
		_oss_c->_tag_decoded = FALSE;
	    } else
		_oss_dec_error(_g, _inconsis_len, 0L);
	}
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    _oss_c->_oss_inbufpos = _bufpos;
    _oss_c->_oss_inbuflen = _buflen;
    return _out_data;
}

static void * _dpAsnTicketSales(OssGlobal * _g)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AsnTicketSales	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(1,0)
    _out_data = (_AsnTicketSales *)_oss_dec_const_alloc(_g, sizeof(_AsnTicketSales));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 1)
	_out_data->shiftNumber = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	OSS_CNTX_SET(2)
	_out_data->cashRegister = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
	OSS_CNTX_SET(3)
	_oss_pdec_ntp_kmstr(_g, &_out_data->startShift, _chars + 0);
	OSS_CNTX_SET(4)
	_oss_pdec_ntp_kmstr(_g, &_out_data->endShift, _chars + 0);
	OSS_CNTX_SET(5)
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	{
	    _seqof1 * _head = NULL;
	    unsigned long count;
	    ossBoolean _last = FALSE;
	    unsigned long _index = 0;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
	    unsigned long _prev_fragm0;
#endif

	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 6)
	    count = _oss_pdec_length(_g, 0, 0, &_last);
	    if (count > 0) {
		_seqof1 * _cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
		_head = _cur;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
		if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
		    _prev_fragm0 = count;
		}
#endif
		for (;;) {
		    _seqof1 * _temp = _cur;
		    OSS_CNTX_SETOCC(_index + 1)
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 7)
			_cur->value.voucherNumber = (OSS_INT32)_oss_pdec_unconstr_limited_int_l(_g, INT_MIN, INT_MAX);
			OSS_CNTX_SET(8)
			_cur->value.summ = _oss_pdec_real(_g);
			OSS_CNTX_SET(9)
			_cur->value.goodsName.length = _oss_pdec_ub_nkmstr_ia(_g, &_cur->value.goodsName.value);

			OSS_CNTX_SET(10)
			_oss_pdec_ntp_kmstr(_g, &_cur->value.timeOfSell, _chars + 0);
			OSS_CNTX_SET(11)
			_cur->value.status = _oss_get_1bit_unaligned(_g) ? TRUE : FALSE;
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    if (++_index >= count) {
			if (_last)
			    break;
			count += _oss_pdec_length(_g, 0, 0, &_last);
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
			if (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES) {
			    if ((!_last) && (_prev_fragm0 < 65536)) {
				OSS_CNTX_SETOCC(_index + 1)
				_oss_dec_error(_g, _invalid_fragmentation, 0L);
			    }
			    _prev_fragm0 = count - _index;
			}
#endif
			if (_index >= count)
			    break;
		    }
		    _cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
		    _temp->next = _cur;
		}
		_cur->next = NULL;
	    } else {
		_head = NULL;
	    }
	    _out_data->vouchers = _head;
	    OSS_CNTX_POP(_oss_c)
	}
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

static void * _dxAsnTicketSales(_Xml_Dec_Env * _env)
{
    OssGlobal *_g = _env->_g;
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _AsnTicketSales	*_out_data;
    OSS_CNTX_INITZERO

    OSS_CNTX_ANCHOR_SET(1,0)
    _oss_tdx_open_tag(_env, (char *)_v_ex_str1);
    _out_data = (_AsnTicketSales *)_oss_dec_const_alloc(_g, sizeof(_AsnTicketSales));
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
	    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
	    _oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
    {
	ossBoolean _open;

	OSS_CNTX_INIT

	OSS_CNTX_PUSH(_oss_c, 1)
	_oss_tdx_open_tag(_env, (char *)_v_ex_str2);
	_out_data->shiftNumber = (OSS_INT32)_oss_tdx_lint(_env, (long)(-2147483647 - 1), (long)(INT_MAX));
	_oss_tdx_close_tag(_env, (char *)_v_ex_str2);
	OSS_CNTX_SET(2)
	_oss_tdx_open_tag(_env, (char *)_v_ex_str3);
	_out_data->cashRegister = (OSS_INT32)_oss_tdx_lint(_env, (long)(-2147483647 - 1), (long)(INT_MAX));
	_oss_tdx_close_tag(_env, (char *)_v_ex_str3);
	OSS_CNTX_SET(3)
	_oss_tdx_open_tag(_env, (char *)_v_ex_str4);
	_oss_tdx_char1_nullterm(_env, &(_out_data->startShift), 0, 0x08);
	if(!(_g->decodingFlags & NOCONSTRAIN))
	    _oss_check_nullterm_time(_g, _out_data->startShift, 1);
	_oss_tdx_close_tag(_env, (char *)_v_ex_str4);
	OSS_CNTX_SET(4)
	_oss_tdx_open_tag(_env, (char *)_v_ex_str5);
	_oss_tdx_char1_nullterm(_env, &(_out_data->endShift), 0, 0x08);
	if(!(_g->decodingFlags & NOCONSTRAIN))
	    _oss_check_nullterm_time(_g, _out_data->endShift, 1);
	_oss_tdx_close_tag(_env, (char *)_v_ex_str5);
	OSS_CNTX_SET(5)
	_open = _oss_tdx_open_or_empty_tag(_env, (char *)_v_ex_str6);
#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
		++_oss_c->reserved.fields.ext->seqSetNestingCounter >
		_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
	if (_open) {
	    _seqof1 *_head;
	    unsigned long	count = 0;

	    OSS_CNTX_INIT

	    OSS_CNTX_PUSH(_oss_c, 6)
	    if (!(_oss_tdx_lexem_lookahead(_env) & L_END)) {
		_seqof1 *_cur;
		_cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
		_head = _cur;
		for(;;) {
		    _seqof1 *_temp = _cur;
		    _oss_tdx_open_tag(_env, (char *)_v_ex_str7);
		    count++;
		    OSS_CNTX_SETOCC(count)
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit &&
			    ++_oss_c->reserved.fields.ext->seqSetNestingCounter >
			    _oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_dec_error(_g, _seq_set_nesting_limit_exceeded, 0L);
#endif
		    {
			ossBoolean _open;

			OSS_CNTX_INIT

			OSS_CNTX_PUSH(_oss_c, 7)
			_oss_tdx_open_tag(_env, (char *)_v_ex_str8);
			_cur->value.voucherNumber = (OSS_INT32)_oss_tdx_lint(_env, (long)(-2147483647 - 1), (long)(INT_MAX));
			_oss_tdx_close_tag(_env, (char *)_v_ex_str8);
			OSS_CNTX_SET(8)
			_oss_tdx_open_tag(_env, (char *)_v_ex_str9);
			_cur->value.summ = (double)_oss_tdx_dreal(_env);
			_oss_tdx_close_tag(_env, (char *)_v_ex_str9);
			OSS_CNTX_SET(9)
			_open = _oss_tdx_open_or_empty_tag(_env, (char *)_v_ex_str10);
			_cur->value.goodsName.length = (OSS_UINT32)_oss_tdx_char1_unbounded(_env, (void **)&_cur->value.goodsName.value, 0, 0x20);
			if (_open)
			    _oss_tdx_close_tag(_env, (char *)_v_ex_str10);
			OSS_CNTX_SET(10)
			_oss_tdx_open_tag(_env, (char *)_v_ex_str11);
			_oss_tdx_char1_nullterm(_env, &(_cur->value.timeOfSell), 0, 0x08);
			if(!(_g->decodingFlags & NOCONSTRAIN))
			    _oss_check_nullterm_time(_g, _cur->value.timeOfSell, 1);
			_oss_tdx_close_tag(_env, (char *)_v_ex_str11);
			OSS_CNTX_SET(11)
			_oss_tdx_open_tag(_env, (char *)_v_ex_str12);
			_cur->value.status = _oss_tdx_bool(_env);
			_oss_tdx_close_tag(_env, (char *)_v_ex_str12);
			OSS_CNTX_POP(_oss_c)
		    }
#ifndef OSS_NO_NESTING_CONTROL
		    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
			_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
		    _oss_tdx_close_tag(_env, (char *)_v_ex_str7);
		    if ((_oss_tdx_lexem_lookahead(_env) & L_END))
			break;
		    _cur = (_seqof1 *)_oss_dec_const_alloc(_g, sizeof(_seqof1));
		    _temp->next = _cur;
		}
		_cur->next = NULL;
	    } else {
		_head = NULL;
	    }
	    _out_data->vouchers = _head;
	    OSS_CNTX_POP(_oss_c)
	} else
	    _out_data->vouchers = NULL;

#ifndef OSS_NO_NESTING_CONTROL
	if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	    _oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
	if (_open)
	    _oss_tdx_close_tag(_env, (char *)_v_ex_str6);
	OSS_CNTX_POP(_oss_c)
    }
#ifndef OSS_NO_NESTING_CONTROL
    if (_oss_c->reserved.fields.ext->seqSetNestingLimit)
	_oss_c->reserved.fields.ext->seqSetNestingCounter--;
#endif
    _oss_tdx_close_tag(_env, (char *)_v_ex_str1);
    OSS_CNTX_POP(_oss_c)
    return _out_data;
}

void DLL_ENTRY_FDEF _dmAsnTest(struct ossGlobal * _g, int * _pdunum, void ** _outbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;

    _oss_c->_oss_context_anchor._state = _decoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_pre(_g, _oss_c->_oss_inbufpos, _oss_c->_oss_inbuflen, NULL);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    *_pdunum = 1;
    *_outbuf = _Decoders[0](_g);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_post(_g, 0, *_pdunum, _outbuf);
#endif
}

void DLL_ENTRY_FDEF _pdAsnTest(struct ossGlobal * _g, int * _pdunum, void ** _outbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _oss_c->_oss_context_anchor._state = _decoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_pre(_g, _oss_c->_oss_inbufpos, _oss_c->_oss_inbuflen, NULL);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    if (_g->encRules == OSS_PER_ALIGNED)
	_oss_c->_aligned = 1;
    else
	_oss_toed_error(_g, _toed_rules_not_supp_err, "UNALIGNED PER");

    *_pdunum = 1;
#ifndef OSS_NO_STRICT_ENCODING_DECODING_CHECKING
    if (!_oss_c->_oss_inbuflen && (_g->decodingFlags & STRICT_ENCODING_DECODING_RULES))
	_oss_dec_error(_g, _more_input, 0L);
#endif
    *_outbuf = _pDecoders[0](_g);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_post(_g, 0, *_pdunum, _outbuf);
#endif
}

void DLL_ENTRY_FDEF _xdAsnTest(struct ossGlobal * _g, int * _pdunum, void ** _outbuf)
{
    _EncDecGlobals *_oss_c = (_EncDecGlobals *)_g->encDecVar;
    _Xml_Dec_Env *_env = _oss_c->reserved.fields.ext->_xde;
    _oss_c->_oss_context_anchor._state = _decoding_data;
    _oss_c->_oss_context_anchor._pdu_number = 0;
#if OSSDEBUG > 0
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_pre(_g, _oss_c->_oss_inbufpos, _oss_c->_oss_inbuflen, NULL);
#else
    _oss_c->_oss_err_msg = NULL;
#endif

    if (_g->encRules == OSS_CXER)
	_oss_toed_error(_g, _toed_rules_not_supp_err, "CANONICAL XER");
    else
	_oss_c->_cxer = 0;
    _oss_tdx_prolog(_env);
    *_pdunum = 1;
    *_outbuf = _xDecoders[0](_env);

#if OSSDEBUG > 0
    _oss_c->_oss_err_msg = NULL;
    if (_oss_c->reserved.fields.ext->debug_flags)
	_oss_db_d_post(_g, 0, *_pdunum, _outbuf);
#endif
}

#if (OSS_TOED_API_LEVEL < 22) || !defined(OSSNOFREEPDU)
#if OSS_TOED_API_LEVEL < 32
#define _oss_dec_free(_g, v)   if (v) _oss_dec_free(_g, v)
#define _oss_free_creal(_g, v) if (v) _oss_free_creal(_g, v)
#endif
static void _fAsnTicketSales(OssGlobal * _g, void * _data)
{
    _AsnTicketSales	*_data_ptr;
    _data_ptr = (_AsnTicketSales *)_data;
    if (_data_ptr) {
	_oss_dec_free(_g, _data_ptr->startShift);
	_oss_dec_free(_g, _data_ptr->endShift);
	if (_data_ptr->vouchers) {
	    _seqof1 * _tempa = _data_ptr->vouchers;
	    _seqof1 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		    _oss_dec_free(_g, _tempa->value.goodsName.value);
		_oss_dec_free(_g, _tempa->value.timeOfSell);
		_oss_dec_free(_g, _tempa);
		_tempa = _tempb;
	    }
	}
    }
    _oss_dec_free(_g, _data_ptr);
}

int DLL_ENTRY_FDEF _fmAsnTest(struct ossGlobal * _g, int _pdunum, void * _data)
{
    if (_pdunum < 1 || _pdunum > 1)
	return PDU_RANGE;
    else
	_FreePDU[_pdunum - 1](_g, _data);

    return PDU_FREED;
}

#endif
#ifdef OSSPRINT
#if OSS_TOED_API_LEVEL < 32
#define _oss_prt_dreal     _oss_prt_real
#define _oss_getdisp_dreal _oss_getdisp_real
#endif
static int _pAsnTicketSales(OssGlobal * _g, void * _data)
{
    _AsnTicketSales	*_data_ptr;
    _data_ptr = (_AsnTicketSales *)_data;
    {
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	_oss_indent(_g, 0);
	ossPrint(_g, "shiftNumber ");
	{
	    LONG_LONG value = _data_ptr->shiftNumber;

	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "cashRegister ");
	{
	    LONG_LONG value = _data_ptr->cashRegister;

	    ossPrint(_g, LLONG_FMT, value);
	}
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "startShift ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->startShift == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->startShift);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "endShift ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
	if (_data_ptr->endShift == NULL)
	    ossPrint(_g, "<<<<<<NULL>>>>>>");
	else
#endif
	    _oss_prt_nchar(_g, (char *)_data_ptr->endShift);
	ossPrint(_g, ",");
	_oss_indent(_g, 0);
	ossPrint(_g, "vouchers ");
	_oss_indent(_g, 1);
	ossPrint(_g, "{");
	if (_data_ptr->vouchers) {
	    _seqof1 * _tempa = _data_ptr->vouchers;
	    _seqof1 * _tempb;
	    while (_tempa) {
		_tempb = _tempa->next;
		{
		    _oss_indent(_g, 1);
		    ossPrint(_g, "{");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "voucherNumber ");
		    {
			LONG_LONG value = _tempa->value.voucherNumber;

			ossPrint(_g, LLONG_FMT, value);
		    }
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "summ ");
		    _oss_prt_dreal(_g, _tempa->value.summ);
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "goodsName ");
		    _oss_prt_mbchar(_g, (unsigned char *)_tempa->value.goodsName.value, _tempa->value.goodsName.length, 1);
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "timeOfSell ");
#ifndef OSS_DO_NOT_CHECK_POINTERS
		    if (_tempa->value.timeOfSell == NULL)
			ossPrint(_g, "<<<<<<NULL>>>>>>");
		    else
#endif
			_oss_prt_nchar(_g, (char *)_tempa->value.timeOfSell);
		    ossPrint(_g, ",");
		    _oss_indent(_g, 0);
		    ossPrint(_g, "status ");
		    ossPrint(_g, _tempa->value.status ? "TRUE" : "FALSE");
		    _oss_indent(_g, -1);
		    ossPrint(_g, "}");
		}
		_tempa = _tempb;
		if (_tempa)
		    ossPrint(_g, ",");
	    }
	}
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
	_oss_indent(_g, -1);
	ossPrint(_g, "}");
    }

    return PDU_PRINTED;
}

int DLL_ENTRY_FDEF _pmAsnTest(struct ossGlobal * _g, int _pdunum, void * _data)
{
    int _rc = _pdunum < 0;

    if (_rc)
	_pdunum = -_pdunum;
    if (_pdunum < 1 || _pdunum > 1 || !_PrintPDU[_pdunum - 1]._pf)
	return PDU_RANGE;
    else {
	if (_rc) {
	    ossPrint(_g, "%s : ", _PrintPDU[_pdunum - 1]._name);
	    _rc = _PrintPDU[_pdunum - 1]._pf(_g, _data);
	} else {
	    ossPrint(_g, "value %s ::= ", _PrintPDU[_pdunum - 1]._name);
	    _rc = _PrintPDU[_pdunum - 1]._pf(_g, _data);
	    ossPrint(_g, "\n");
	}
    }

    return _rc;
}

#endif

#ifdef OSS_COPY_VALUE
#define _oss_c ((_EncDecGlobals*)_g->encDecVar)

int DLL_ENTRY_FDEF _CPAsnTest(struct ossGlobal * _g, int pduNum, void * src, void ** pdst)
{
    int res = 0;
    void *pdVal = NULL;

    if (pduNum <= 0 || pduNum > 2)
	return PDU_RANGE;
    switch (pduNum) {
	case 1: {
	    pdVal = (_AsnTicketSales  *)_oss_dec_const_alloc(_g, sizeof(_AsnTicketSales ));
	    memcpy((_AsnTicketSales  *)pdVal, (_AsnTicketSales  *)src, sizeof(*(_AsnTicketSales  *)pdVal));
	    {
		size_t  len_1 = (size_t)sizeof(char) * (strlen((*(_AsnTicketSales  *)src).startShift) + 1);

		(*(_AsnTicketSales  *)pdVal).startShift = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		strcpy((*(_AsnTicketSales  *)pdVal).startShift, (*(_AsnTicketSales  *)src).startShift);
	    }
	    {
		size_t  len_1 = (size_t)sizeof(char) * (strlen((*(_AsnTicketSales  *)src).endShift) + 1);

		(*(_AsnTicketSales  *)pdVal).endShift = (char * )_oss_dec_getmem_internal(_g, (long)len_1);
		strcpy((*(_AsnTicketSales  *)pdVal).endShift, (*(_AsnTicketSales  *)src).endShift);
	    }
	    {
		(*(_AsnTicketSales  *)pdVal).vouchers = NULL;
		if ((*(_AsnTicketSales  *)src).vouchers) {
		    _seqof1 *  s_oss_tmp_2 = (*(_AsnTicketSales  *)src).vouchers;
		    _seqof1 *  d_oss_tmp_2;

		    (*(_AsnTicketSales  *)pdVal).vouchers = d_oss_tmp_2 = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
		    do {
			memcpy(d_oss_tmp_2, s_oss_tmp_2, sizeof(_seqof1));
			{
			    {
				_oss_cpy_unbnd_octet_ia(_g, &((s_oss_tmp_2->value).goodsName), &((d_oss_tmp_2->value).goodsName), sizeof(((d_oss_tmp_2->value).goodsName).length), sizeof(((d_oss_tmp_2->value).goodsName).value[0]), (unsigned int)((char *)&((s_oss_tmp_2->value).goodsName).value - (char *)&((s_oss_tmp_2->value).goodsName)));
			    }
			    {
				char *  * src_3 = &((s_oss_tmp_2->value).timeOfSell);
				char *  * dst_3 = &((d_oss_tmp_2->value).timeOfSell);
				size_t  len_3 = (size_t)sizeof(char) * (strlen(*src_3) + 1);

				*dst_3 = (char * )_oss_dec_getmem_internal(_g, (long)len_3);
				strcpy(*dst_3, *src_3);
			    }
			}
			if (s_oss_tmp_2->next)
			    d_oss_tmp_2->next = (_seqof1 *)_oss_dec_getmem_internal(_g, sizeof(_seqof1));
			s_oss_tmp_2 = s_oss_tmp_2->next;
			d_oss_tmp_2 = d_oss_tmp_2->next;
		    } while (s_oss_tmp_2);
		}
	    }
	} break;
	default:
	    res = PDU_RANGE;
    }
    *pdst = pdVal;
    return res;
}
#undef _oss_c
#endif /* OSS_COPY_VALUE */

#ifdef OSS_COMPARE_VALUE
int DLL_ENTRY_FDEF _CMAsnTest(struct ossGlobal * _g, int _pduNum, void * _odata, void * _cdata)
{
    int _res = 0;

    if (_pduNum <= 0 || _pduNum > 2)
	return PDU_RANGE;
    switch (_pduNum) {
	case 1: {
	    if ((*(_AsnTicketSales  *)_cdata).shiftNumber != (*(_AsnTicketSales  *)_odata).shiftNumber)
		return 1;
	    if ((*(_AsnTicketSales  *)_cdata).cashRegister != (*(_AsnTicketSales  *)_odata).cashRegister)
		return 1;
	    if (strcmp((*(_AsnTicketSales  *)_cdata).startShift, (*(_AsnTicketSales  *)_odata).startShift))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time((*(_AsnTicketSales  *)_cdata).startShift, (*(_AsnTicketSales  *)_odata).startShift, 1))
#endif
		    return 1;
	    if (strcmp((*(_AsnTicketSales  *)_cdata).endShift, (*(_AsnTicketSales  *)_odata).endShift))
#ifdef BAD_OID_IRI
		if (_oss_cmp_str2time((*(_AsnTicketSales  *)_cdata).endShift, (*(_AsnTicketSales  *)_odata).endShift, 1))
#endif
		    return 1;
	    {
		_seqof1 *  _s_oss_tmp_2 = (*(_AsnTicketSales  *)_odata).vouchers;
		_seqof1 *  _d_oss_tmp_2 = (*(_AsnTicketSales  *)_cdata).vouchers;

		while (_s_oss_tmp_2 && _d_oss_tmp_2) {
		    if ((_d_oss_tmp_2->value).voucherNumber != (_s_oss_tmp_2->value).voucherNumber)
			return 1;
		    if (memcmp(&((_d_oss_tmp_2->value).summ), &((_s_oss_tmp_2->value).summ), sizeof(double)))
			return 1;
		    if (_oss_cmp_unbnd_octet_ia(&((_s_oss_tmp_2->value).goodsName), &((_d_oss_tmp_2->value).goodsName), sizeof(((_d_oss_tmp_2->value).goodsName).length), sizeof(((_d_oss_tmp_2->value).goodsName).value[0]), (unsigned int)((char *)&((_s_oss_tmp_2->value).goodsName).value - (char *)&((_s_oss_tmp_2->value).goodsName))))
			return 1;
		    if (strcmp((_d_oss_tmp_2->value).timeOfSell, (_s_oss_tmp_2->value).timeOfSell))
#ifdef BAD_OID_IRI
			if (_oss_cmp_str2time((_d_oss_tmp_2->value).timeOfSell, (_s_oss_tmp_2->value).timeOfSell, 1))
#endif
			    return 1;
		    if (((_d_oss_tmp_2->value).status ^ (_s_oss_tmp_2->value).status) & 0x01)
			return 1;
		    _s_oss_tmp_2 = _s_oss_tmp_2->next;
		    _d_oss_tmp_2 = _d_oss_tmp_2->next;
		}
		if (_s_oss_tmp_2 || _d_oss_tmp_2)
		    return 1;
	    }
	} break;
	default:
	    return PDU_RANGE;
    }
    return _res;
}
#endif /* OSS_COMPARE_VALUE */

/* Entry points */
static const _entry_point_struct _entry_points = {_ossinit_asn_bench, _emAsnTest, _dmAsnTest, 
#if (OSS_TOED_API_LEVEL < 22 ) || !defined(OSSNOFREEPDU)
_fmAsnTest,
#else
NULL, 
#endif
117,
_peAsnTest, _pdAsnTest, 116, 0, NULL,
#ifdef OSSPRINT
_pmAsnTest
#else
NULL
#endif
};
static void _oss_post_init(struct ossGlobal *world) {
    static const unsigned char _oss_typeinfo[] = {
        0x00, 0x5c, 0x34, 0xc0, 0x78, 0x31, 0x6c, 0xd9, 0x22, 0xe2,
        0x40, 0xdb, 0x22, 0xe1, 0x40, 0x77, 0xd6, 0x4c, 0xec, 0xb6,
        0x4e, 0x35, 0xba, 0x27, 0x8d, 0x44, 0x79, 0x8c, 0xc1, 0x2f,
        0x9d, 0x25, 0x4e, 0xf3, 0xa8, 0x3a, 0x9f, 0x15, 0xed, 0x14,
        0xf4, 0x22, 0xf0, 0xf2, 0x35, 0xe2, 0xb4, 0x97, 0x57, 0xe8,
        0x8c, 0xf9, 0xea, 0xf6, 0xf3, 0xd6, 0xb0, 0x19, 0xb5, 0x02,
        0xb1, 0xe2, 0x05, 0xe9, 0xf6, 0x7b, 0x8b, 0xf3, 0x1e, 0x75,
        0xf0, 0x1e, 0xa8, 0x14, 0x77, 0xc1, 0x98, 0x0a, 0xa8, 0x8c,
        0xf4, 0x4e, 0x6d, 0xf1, 0xdc, 0xf0, 0x35, 0x7b, 0xb7, 0x97,
        0xda, 0x47, 0x6f, 0x02
    };
    ossInitRootContext1(world, (unsigned char *)_oss_typeinfo);
}

} /* extern "C" */

void *asn_bench_TableType::internal = (void *)&_entry_points;
