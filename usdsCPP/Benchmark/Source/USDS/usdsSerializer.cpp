// This file must be autogenerated

#include "USDS\usdsSerializer.h"

UsdsSerializer::UsdsSerializer()
{
	usds_buff = 0;
	default_doc_size = 4096;
	usds_buff = new unsigned char[default_doc_size];
	if (usds_buff == 0)
	{
		buff_last_pos = 0;
		buff_current_pos = 0;
	}
	else
	{
		buff_last_pos = usds_buff + default_doc_size;
		buff_current_pos = usds_buff;
	}

	// default version is the lastest
	usds_major = 1;
	usds_minor = 0;
	dictionary_major = 1;
	dictionary_minor = 0;
	full_dictionary_version = dictionary_major * 256 + dictionary_minor;

	// current status
	head_added = false;
	dictionary_added = false;
	body_added = false;
	body_finished = false;
	control_added = false;
	index_added = false;

};

UsdsSerializer::UsdsSerializer(int binary_typical_size)
{
	usds_buff = 0;
	
	// Add 25% for overhead
	binary_typical_size = binary_typical_size + binary_typical_size/4;
	// Size have to be a multiple of 64
	default_doc_size = (binary_typical_size/64+1)*64;
	usds_buff = new unsigned char[default_doc_size];
	if (usds_buff == 0)
	{
		buff_last_pos = 0;
		buff_current_pos = 0;
	}
	else
	{
		buff_last_pos = usds_buff + default_doc_size;
		buff_current_pos = usds_buff;
	}

	// default version is the lastest
	usds_major = 1;
	usds_minor = 0;
	dictionary_major = 1;
	dictionary_minor = 0;
	full_dictionary_version = dictionary_major * 256 + dictionary_minor;

	// current status
	head_added = false;
	body_added = false;
	body_finished = false;
	dictionary_added = false;
	index_added = false;
	control_added = false;
};

UsdsSerializer::~UsdsSerializer()
{
	if (usds_buff != 0)
		delete[] usds_buff;
};

//====================================================================================================================
// Settings
// Set for binary (serialization)
int UsdsSerializer::setUsdsVersion(unsigned char major, unsigned char minor)
{
	usds_major = major;
	usds_minor = minor;
	return 0;
};
int UsdsSerializer::setDictionaryVersion(unsigned char major, unsigned char minor)
{
	dictionary_major = major;
	dictionary_minor = minor;
	full_dictionary_version = dictionary_major * 256 + dictionary_minor;
	return 0;
};

//====================================================================================================================
// Serialization
int UsdsSerializer::addToBody(TicketSales* data)
{
	if (index_added || control_added)
		return -1;

	if (body_finished)
		return -2;

	switch (full_dictionary_version)	// checking dictionary version
	{
		case 256:
		{
			int num_vouchers = data->getNumVouchers();
			if (num_vouchers < 0)
				return -3;

			if (resizeArray(35) != 0)
				return -4;

			if (!body_added)
			{
				*buff_current_pos = 'B';	// add tag ID for Body
				buff_current_pos++;
				body_added = true;
			}

			// Add data to Body
			*buff_current_pos = 1;	// add tag ID for class TicketSales
			buff_current_pos++;

			// add ShiftNumber as unsigned varint BASE128
			if (addVarint(data->getShiftNumber()) != 0)
				return -7;

			// add CashRegister
			addLEInt(data->getCashRegister());

			// add startShift
			addLETimestamp64(data->getStartShift());

			// add endShift
			addLETimestamp64(data->getEndShift());

			// add "vouchers" array size in unsigned varint BASE128
			addVarint(num_vouchers);

			if (num_vouchers == 0)
				return 0;

			// add array "vouchers"
			voucher* vouchers = 0;
			vouchers = data->getVouchers();
			if (vouchers == 0)
				return -5;

			for (int i = 0; i < num_vouchers; i++)
			{
				if (resizeArray(149) != 0)
					return -6;
				// add voucher_number
				if (addVarint(vouchers[i].voucher_number) != 0)
					return -8;
				// add summ
				addLEDouble(vouchers[i].summ);
				// add goods_name
				if (addStringUTF8NoConvert(vouchers[i].goods_name, 128) != 0)
					return -9;
				// add time_of_sell
				addLETimestamp64(vouchers[i].time_of_sell);
				// add status
				addBool(vouchers[i].status);
			}

			return 0;
		}
		default:
			return -1;
	}

};

int UsdsSerializer::getUSDS(unsigned char** data, int* size)
{
	if (buff_current_pos == 0)
		return -1;

	if (body_added && !body_finished)
	{
		if ((buff_last_pos - buff_current_pos) < 1)
			if (resizeArray(1) != 0)
				return -2;
		*buff_current_pos = 0; // finishing body block
		buff_current_pos++;
		body_finished = true;
	}

	*data = usds_buff;
	*size = buff_current_pos - usds_buff;
	return 0;
};

int UsdsSerializer::clean()
{
	buff_current_pos = usds_buff;
	
	head_added = false;
	dictionary_added = false;
	body_added = false;
	body_finished = false;
	control_added = false;
	index_added = false;
	
	return 0;
}

int UsdsSerializer::deleteUSDS()
{
	head_added = false;
	dictionary_added = false;
	body_added = false;
	body_finished = false;
	control_added = false;
	index_added = false;

	if (usds_buff != 0)
		delete[] usds_buff;
	usds_buff = 0;
	usds_buff = new unsigned char[default_doc_size];
	if (usds_buff == 0)
	{
		buff_last_pos = 0;
		buff_current_pos = 0;
	}
	else
	{
		buff_last_pos = usds_buff + default_doc_size;
		buff_current_pos = usds_buff;
	}

	return 0;
};

//====================================================================================================================
int UsdsSerializer::addHead()
{
	if ((buff_last_pos - buff_current_pos) < 10)
		if (resizeArray(10) != 0)
			return -1;

	if (buff_current_pos != usds_buff)
		return -2;
	// '$S' - USDS signature
	// "120, 3, 0, 0" - dictionary ID (unsigned long) = 888.

	usds_buff[0] = '$';
	usds_buff[1] = 'S';
	usds_buff[2] = usds_major;
	usds_buff[3] = usds_minor;
	usds_buff[4] = 120;
	usds_buff[5] = 3;
	usds_buff[6] = 0;
	usds_buff[7] = 0;
	usds_buff[8] = dictionary_major;
	usds_buff[9] = dictionary_minor;

	buff_current_pos += 10;

	head_added = true;
	return 0;
};

int UsdsSerializer::addDictionary()
{
	if ((buff_last_pos - buff_current_pos) < 64)
		if (resizeArray(64) != 0)
			return -1;
	if (body_added)
		return -2;
	if (dictionary_added)
		return -3;
	if (index_added)
		return -4;
	if (control_added)
		return -5;
	if (!head_added)
		return -6;
	
	unsigned char dict_buf[] = {
		// 'D' - Dictionary signature, dictionary size in bytes (varInt), text encode = 2 fo "utf-8" (varInt)
		'D', 61, 2,
		// Structure description: 'U' - User defined types, type ID = 1 (varInt), USDS type = 3 for Struct (varInt), type name size in bytes (varInt, 1)
		'u', 1, 3, 1, 'I',
		// The first field: field ID = 1 (varInt), USDS type = 12 for VarintBase128 (varInt), type name size in bytes (varInt, 1)
		1, 12, 1, 'n',
		// The second field: field ID = 2 (varInt), USDS type = 15 for Double (varInt), type name size in bytes (varInt, 1)
		2, 15, 1, 's',
		// The third field: field ID = 3 (varInt), USDS type = 4 for String (varInt), text encode = 2 fo "utf-8" (varInt), type name size in bytes (varInt, 1)
		3, 4, 2, 1, 'g',
		// The fourth field: field ID = 4 (varInt), USDS type = 112 for Timestamp64 (varInt), type name size in bytes (varInt, 1)
		4, 112, 1, 't',
		// The fifth field: field ID = 5 (varInt), USDS type = 5 for Boolean (varInt), type name size in bytes (varInt, 1)
		5, 5, 1, 'b',
		// The end of Structure
		0,

		// Tag description: 't' - tag, tag ID = 1 (varInt), tag USDS type = 3 for Struct (varInt), tag name size in bytes (varInt, 1)
		't', 1, 3, 1, 'S',
		// The first field: field ID = 1 (varInt), USDS type = 12 for VarintBase128 (varInt), type name size in bytes (varInt, 1)
		1, 12, 1, 'n',
		// The second field: field ID = 2 (varInt), USDS type = 12 for VarintBase128 (varInt), type name size in bytes (varInt, 1)
		2, 12, 1, 'm',
		// The third field: field ID = 3 (varInt), USDS type = 112 for Timestamp64 (varInt), type name size in bytes (varInt, 1)
		3, 112, 1, 's',
		// The fourth field: field ID = 4 (varInt), USDS type = 112 for Timestamp64 (varInt), type name size in bytes (varInt, 1)
		4, 112, 1, 'e',
		// The fifth field: field ID = 5 (varInt), USDS type = 2 for Array (varInt), type for elements = 0, 1 - User defined (ID=1), array size = 0 - any, type name size in bytes (varInt, 1)
		5, 2, 0, 1, 0, 1, 'v',
		// The sixth field: field ID = 6 (varInt), USDS type = 12 for VarintBase128 (varInt), type name size in bytes (varInt, 1)
		6, 12, 1, 'c',
		// The end of Structure
		0
	};
	
	memcpy(buff_current_pos, dict_buf, 63);
	buff_current_pos += 63;

	dictionary_added = true;
	
	return 0;
};
int UsdsSerializer::addIndex()
{
	/*
	if (!body_added)
		return -1;

	if (index_added)
		return -2;
	
	if (!body_finished)
	{
		out_binary->push_back(0); // finishing body block
		body_finished = true;
	};

	index_added = true;
	*/
	return 0;
};
int UsdsSerializer::addControl()
{
	/*
	if (!body_added && !dictionary_added)
		return -1;

	if (control_added)
		return -2;

	if (body_added && !body_finished)
	{
		out_binary->push_back(0); // finishing body block
		body_finished = true;
	};

	control_added = true;
	*/
	return 0;
};

inline int UsdsSerializer::resizeArray(int minIncrease)
{
	if ((buff_last_pos - buff_current_pos) >= minIncrease)
		return 0;

	// New size is +25%, but it have to be more, then size+minIncrease
	int buff_current_size = buff_last_pos - usds_buff;
	int doc_current_size = buff_current_pos - usds_buff;
	int new_size = buff_current_size + buff_current_size/4;
	if ((new_size - buff_current_size) < minIncrease)
		new_size = buff_current_size + minIncrease;
	// Size have to be a multiple of 64 byte
	new_size = (new_size / 64 + 1) * 64;
	
	unsigned char* new_usds_buff = 0;
	new_usds_buff = new unsigned char[new_size];
	if (new_usds_buff == 0)
		return -1;

	memcpy(new_usds_buff, usds_buff, doc_current_size);
	
	delete[] usds_buff;
	usds_buff = new_usds_buff;
	buff_current_pos = usds_buff + doc_current_size;
	buff_last_pos = usds_buff + new_size;

	return 0;
};

inline int UsdsSerializer::addVarint(int value)
{
	if (value < 0)
		return -1;

	// step 1 of 5
	memcpy(buff_current_pos, &value, 4);
	buff_current_pos++;
	if (value < 128)
		return 0;
	
	// step 2 of 5
	buff_current_pos[3] = 0;
	*((int*)buff_current_pos) <<= 1;
	if (*(buff_current_pos - 1) & 128)
		*buff_current_pos |= 1;
	else
		*(buff_current_pos-1) |= 128;

	buff_current_pos++;
	if (value < 16384)
		return 0;

	// step 3 of 5
	*((int*)buff_current_pos) <<= 1;
	if (*(buff_current_pos - 1) & 128)
		*buff_current_pos |= 1;
	else
		*(buff_current_pos - 1) |= 128;
	buff_current_pos++;
	if (value < 2097152)
		return 0;

	// step 4 of 5
	*((int*)buff_current_pos) <<= 1;
	if (*(buff_current_pos - 1) & 128)
		*buff_current_pos |= 1;
	else
		*(buff_current_pos - 1) |= 128;
	buff_current_pos++;
	if (value < 268435456)
		return 0;

	// step 5 of 5
	*((int*)buff_current_pos) <<= 1;
	if (*(buff_current_pos - 1) & 128)
		*buff_current_pos |= 1;
	else
		*(buff_current_pos - 1) |= 128;
	buff_current_pos++;

	return 0;
};

inline void UsdsSerializer::addLEInt(int value)
{
	memcpy(buff_current_pos, &value, 4);
	buff_current_pos +=4;
	return;
};

inline void UsdsSerializer::addLETimestamp64(time_t value)
{
	memcpy(buff_current_pos, &value, 8);
	buff_current_pos += 8;
	return;
};

inline void UsdsSerializer::addLEDouble(double value)
{
	memcpy(buff_current_pos, &value, 8);
	buff_current_pos += 8;
	return;
};

inline int UsdsSerializer::addStringUTF8NoConvert(char* value, int max_size)
{
	// add string size in unsigned varint BASE128
	int str_size = strlen(value);
	if (str_size<0 || str_size>=max_size)
		return -1;
	addVarint(str_size);
	// add string without NULL-simbol
	memcpy(buff_current_pos, value, str_size);
	buff_current_pos += str_size;
	
	return 0;
};

inline void UsdsSerializer::addBool(bool value)
{
	if (value)
		*buff_current_pos = 255;
	else
		*buff_current_pos = 0;
	buff_current_pos++;
	return;
}