// This file must be autogenerated

#include "USDS DOM\usdsDomParser.h"

UsdsDomParser::UsdsDomParser()
{
	lastUSDSTicketSales = buffUSDSTicketSales.begin();
	lastUSDSVoucher = buffUSDSVoucher.begin();
	
	firstRoot = 0;
	lastRoot = 0;

	// Outut buffer
	out_usds_buff = 0;
	out_default_doc_size = 4096;
	out_usds_buff = new unsigned char[out_default_doc_size];
	if (out_usds_buff == 0)
	{
		out_buff_last_pos = 0;
		out_buff_current_pos = 0;
	}
	else
	{
		out_buff_last_pos = out_usds_buff + out_default_doc_size;
		out_buff_current_pos = out_usds_buff;
	}

	// Input buffer
	in_usds_buff = 0;
	in_buff_last_pos = 0;
	in_buff_current_pos = 0;
	in_buff_body_pos = 0;
	in_buff_body_last_pos = 0;

	//the last version id default 
	usds_major = 1;
	usds_minor = 0;
	dictionary_major = 1;
	dictionary_minor = 0;
	full_dictionary_version = dictionary_major * 256 + dictionary_minor;

	// current status
	out_head_added = false;
	out_dictionary_added = false;
	out_body_added = false;
	in_head_included = false;
	in_dictionary_included = false;
};

UsdsDomParser::~UsdsDomParser()
{
	if (out_usds_buff != 0)
		delete[] out_usds_buff;
};

//====================================================================================================================
// Settings
// Set for binary (serialization)
int UsdsDomParser::setUsdsVersion(unsigned char major, unsigned char minor)
{
	usds_major = major;
	usds_minor = minor;
	return 0;
};
int UsdsDomParser::setDictionaryVersion(unsigned char major, unsigned char minor)
{
	dictionary_major = major;
	dictionary_minor = minor;
	full_dictionary_version = dictionary_major * 256 + dictionary_minor;
	return 0;
};

//====================================================================================================================
UsdsTicketSales* UsdsDomParser::addUsdsTicketSales()
{
	if (lastUSDSTicketSales == buffUSDSTicketSales.end())
	{
		buffUSDSTicketSales.push_back(UsdsTicketSales(this));
		lastUSDSTicketSales = buffUSDSTicketSales.end();
		lastUSDSTicketSales--;
	}
	UsdsTicketSales* object = &(*lastUSDSTicketSales);
	lastUSDSTicketSales++;

	object->init(firstRoot, 0);
	if (firstRoot == 0)
		firstRoot = object;
	else
		lastRoot->setNextObject(object);
	lastRoot = object;

	return object;
};

UsdsVoucher* UsdsDomParser::addUsdsVoucher()
{
	if (lastUSDSVoucher == buffUSDSVoucher.end())
	{
		buffUSDSVoucher.push_back(UsdsVoucher(this));
		lastUSDSVoucher = buffUSDSVoucher.end();
		lastUSDSVoucher--;
	}
	UsdsVoucher* object = &(*lastUSDSVoucher);
	lastUSDSVoucher++;

	return object;
};


void UsdsDomParser::clean()
{
	lastUSDSTicketSales = buffUSDSTicketSales.begin();
	lastUSDSVoucher = buffUSDSVoucher.begin();

	firstRoot = 0;
	lastRoot = 0;
		
	// output buffer
	out_buff_current_pos = out_usds_buff;
	out_head_added = false;
	out_dictionary_added = false;
	out_body_added = false;

	// input buffer
	in_usds_buff = 0;
	in_buff_last_pos = 0;
	in_buff_current_pos = 0;
	in_buff_body_pos = 0;
	in_buff_body_last_pos = 0;
	in_buff_body_last_pos = 0;
	in_head_included = false;
	in_dictionary_included = false;
};

//====================================================================================================================
// Serialization
int UsdsDomParser::addBody()
{
	if (out_body_added)
		return -1;

	switch (full_dictionary_version)	// checking dictionary version
	{
	case 256:
	{
				UsdsTicketSales* data = (UsdsTicketSales*)firstRoot;
				if (data == 0)
					return -2;

				if (resizeArray(35) != 0)
					return -3;

				*out_buff_current_pos = 'B';	// add tag ID for Body
				out_buff_current_pos++;

				while (data != 0)
				{
					if (resizeArray(35) != 0)
						return -4;

					// Add data to Body
					*out_buff_current_pos = USDS_TICKET_SALES;	// add tag ID for class TicketSales
					out_buff_current_pos++;

					// add ShiftNumber as unsigned varint BASE128
					if (addVarint(data->shiftNumber) != 0)
						return -5;

					// add CashRegister
					addLEInt(data->cashRegister);

					// add startShift
					addLETimestamp64(data->startShift);

					// add endShift
					addLETimestamp64(data->endShift);

					// add "vouchers" array size in unsigned varint BASE128
					int num_vouchers = data->getVouchersSize();
					if (num_vouchers < 0)
						return -6;
					if (addVarint(data->getVouchersSize()) != 0)
						return -7;
					if (num_vouchers == 0)
						continue;

					// add array "vouchers"
					UsdsVoucher* vouchers = data->getFirstInVouchers();
					if (vouchers == 0)
						return -8;

					while (vouchers != 0)
					{
						if (resizeArray(149) != 0)
							return -9;
						// add voucher_number
						if (addVarint(vouchers->voucher_number) != 0)
							return -10;
						// add summ
						addLEDouble(vouchers->summ);
						// add goods_name
						if (addStringUTF8NoConvert(vouchers->getGoods_name(), 128) != 0)
							return -11;
						// add time_of_sell
						addLETimestamp64(vouchers->time_of_sell);
						// add status
						addBool(vouchers->status);
						
						vouchers = (UsdsVoucher*)vouchers->getNextObject();
					}

					data = (UsdsTicketSales*)data->getNextObject();
				} 

				out_body_added = true;
				*out_buff_current_pos = 0; // finishing body block
				out_buff_current_pos++;

				return 0;

	}
	default:
		return -1;
	}

};

int UsdsDomParser::getUSDS(unsigned char** data, int* size)
{
	if (out_buff_current_pos == 0)
		return -1;

	if (out_head_added && (!out_dictionary_added && !out_body_added))
		return -2;

	*data = out_usds_buff;
	*size = out_buff_current_pos - out_usds_buff;
	return 0;
};

//====================================================================================================================
// Deserialization
int UsdsDomParser::parse(unsigned char* data, int data_size)
{
	if (data == 0 || data_size == 0)
		return -1;

	// parse heads
	in_usds_buff = data;
	in_buff_last_pos = in_usds_buff + data_size;
	in_buff_current_pos = in_usds_buff;

	if (in_buff_current_pos[0] == '$')
	{
		if (in_buff_current_pos[4] != 120 || in_buff_current_pos[5] != 3 || in_buff_current_pos[6] != 0 || in_buff_current_pos[7] != 0)
			return -1;
		if (in_buff_current_pos[8] != 1 || in_buff_current_pos[9] != 0)
			return -2;
		in_head_included = true;
		usds_major = in_buff_current_pos[2];
		usds_minor = in_buff_current_pos[3];
		dictionary_major = in_buff_current_pos[8];
		dictionary_minor = in_buff_current_pos[9];
		full_dictionary_version = dictionary_major * 256 + dictionary_minor;
		in_buff_current_pos += 10;
	}

	if (in_buff_current_pos[0] == 'D')
	{
		in_buff_current_pos++;
		int dict_size = 0;
		if (getVarint(&dict_size) != 0)
			return -3;
		in_buff_current_pos += dict_size;

	}

	if (in_buff_current_pos[0] == 'B')
	{
		in_buff_body_pos = in_buff_current_pos + 1;
		in_buff_body_last_pos = in_buff_last_pos - 1;
		if (*in_buff_body_last_pos != 0)
			return -4;
	}

	// parse body
	in_buff_current_pos = in_buff_body_pos;

	switch (full_dictionary_version)	// checking dictionary version
	{
	case 256:
	{
				// while not end of the body
				while (*in_buff_current_pos != 0)
				{
					if (in_buff_current_pos >= in_buff_body_last_pos)		// Body oversized
						return -5;

					UsdsTicketSales* tag = 0;
					if (*in_buff_current_pos == USDS_TICKET_SALES)
						tag = addUsdsTicketSales();
					else
						return -6;
					// Tag have found, initialising TicketSales										
					// Go to first fild
					in_buff_current_pos++;
					if (in_buff_body_last_pos - in_buff_current_pos < 22)	// checking minimal size of a USDSTicketSales
						return -7;
					// set shiftNumber
					
					if (getVarint(&(tag->shiftNumber)) != 0)
						return -8;
					if (in_buff_body_last_pos - in_buff_current_pos < 21)
						return -9;
					// set cashRegister
					getLEInt(&(tag->cashRegister));
					// set startShift
					setLETimestamp64(&(tag->startShift));
					// set endShift
					setLETimestamp64(&(tag->endShift));
					// get size of Vouchers
					int numVouchers;
					if (getVarint(&numVouchers) != 0)
						return -10;
					if (numVouchers == 0)
						continue;
					// add array
					for (int i = 0; i < numVouchers; i++)
					{
						UsdsVoucher* vouchers = tag->addToVouchers();
						if (in_buff_body_last_pos - in_buff_current_pos < 20)
							return -11;
						// set voucher_number
						if (getVarint(&(vouchers->voucher_number)) != 0)
							return -12;
						if (in_buff_body_last_pos - in_buff_current_pos < 19)
							return -13;
						// set summ
						setLEDouble(&(vouchers->summ));
						// set goods_name
						char text_buff[128];
						if (setStringUTF8NoConvert(text_buff, 128) != 0)
							return -14;
						vouchers->setGoods_name(USDS_DOM_UTF8, text_buff);
						if (in_buff_body_last_pos - in_buff_current_pos < 5)
							return -15;
						// set time_of_sell
						setLETimestamp64(&(vouchers->time_of_sell));
						// set status
						setBool(&(vouchers->status));

					};

				}
				return 0;
	}
	default:
		// Unsupportable dictionary version
		return -6;
	}


	return 0;
};


//====================================================================================================================
int UsdsDomParser::addHead()
{
	if ((out_buff_last_pos - out_buff_current_pos) < 10)
		if (resizeArray(10) != 0)
			return -1;

	if (out_buff_current_pos != out_usds_buff)
		return -2;
	// '$S' - USDS signature
	// "120, 3, 0, 0" - dictionary ID (unsigned long) = 888.

	out_usds_buff[0] = '$';
	out_usds_buff[1] = 'S';
	out_usds_buff[2] = usds_major;
	out_usds_buff[3] = usds_minor;
	out_usds_buff[4] = 120;
	out_usds_buff[5] = 3;
	out_usds_buff[6] = 0;
	out_usds_buff[7] = 0;
	out_usds_buff[8] = dictionary_major;
	out_usds_buff[9] = dictionary_minor;

	out_buff_current_pos += 10;

	out_head_added = true;
	return 0;
};

int UsdsDomParser::addDictionary()
{
	if ((out_buff_last_pos - out_buff_current_pos) < 64)
		if (resizeArray(64) != 0)
			return -1;
	if (out_body_added)
		return -2;
	if (out_dictionary_added)
		return -3;
	if (!out_head_added)
		return -6;

	unsigned char dict_buf[] = {
		// 'D' - Dictionary signature, dictionary size in bytes (varInt), text encode = 2 fo "utf-8" (varInt)
		'D', 61, 2,
		// Structure description: 'U' - User defined types, type ID = 1 (varInt), USDS type = 3 for Struct (varInt), type name size in bytes (varInt, 1)
		'u', 1, 3, 1, 'I',
		// The first field: field ID = 1 (varInt), USDS type = 12 for VarintBase128 (varInt), type name size in bytes (varInt, 1)
		1, 12, 1, 'n',
		// The second field: field ID = 2 (varInt), USDS type = 15 for Double (varInt), type name size in bytes (varInt, 1)
		2, 15, 1, 's',
		// The third field: field ID = 3 (varInt), USDS type = 4 for String (varInt), text encode = 2 fo "utf-8" (varInt), type name size in bytes (varInt, 1)
		3, 4, 2, 1, 'g',
		// The fourth field: field ID = 4 (varInt), USDS type = 112 for Timestamp64 (varInt), type name size in bytes (varInt, 1)
		4, 112, 1, 't',
		// The fifth field: field ID = 5 (varInt), USDS type = 5 for Boolean (varInt), type name size in bytes (varInt, 1)
		5, 5, 1, 'b',
		// The end of Structure
		0,

		// Tag description: 't' - tag, tag ID = 1 (varInt), tag USDS type = 3 for Struct (varInt), tag name size in bytes (varInt, 1)
		't', 1, 3, 1, 'S',
		// The first field: field ID = 1 (varInt), USDS type = 12 for VarintBase128 (varInt), type name size in bytes (varInt, 1)
		1, 12, 1, 'n',
		// The second field: field ID = 2 (varInt), USDS type = 12 for VarintBase128 (varInt), type name size in bytes (varInt, 1)
		2, 12, 1, 'm',
		// The third field: field ID = 3 (varInt), USDS type = 112 for Timestamp64 (varInt), type name size in bytes (varInt, 1)
		3, 112, 1, 's',
		// The fourth field: field ID = 4 (varInt), USDS type = 112 for Timestamp64 (varInt), type name size in bytes (varInt, 1)
		4, 112, 1, 'e',
		// The fifth field: field ID = 5 (varInt), USDS type = 2 for Array (varInt), type for elements = 0, 1 - User defined (ID=1), array size = 0 - any, type name size in bytes (varInt, 1)
		5, 2, 0, 1, 0, 1, 'v',
		// The sixth field: field ID = 6 (varInt), USDS type = 12 for VarintBase128 (varInt), type name size in bytes (varInt, 1)
		6, 12, 1, 'c',
		// The end of Structure
		0
	};

	memcpy(out_buff_current_pos, dict_buf, 63);
	out_buff_current_pos += 63;

	out_dictionary_added = true;

	return 0;
};

inline int UsdsDomParser::resizeArray(int minIncrease)
{
	if ((out_buff_last_pos - out_buff_current_pos) >= minIncrease)
		return 0;

	// New size is +25%, but it have to be more, then size+minIncrease
	int buff_current_size = out_buff_last_pos - out_usds_buff;
	int doc_current_size = out_buff_current_pos - out_usds_buff;
	int new_size = buff_current_size + buff_current_size / 4;
	if ((new_size - buff_current_size) < minIncrease)
		new_size = buff_current_size + minIncrease;
	// Size have to be a multiple of 64 byte
	new_size = (new_size / 64 + 1) * 64;

	unsigned char* new_usds_buff = 0;
	new_usds_buff = new unsigned char[new_size];
	if (new_usds_buff == 0)
		return -1;

	memcpy(new_usds_buff, out_usds_buff, doc_current_size);

	delete[] out_usds_buff;
	out_usds_buff = new_usds_buff;
	out_buff_current_pos = out_usds_buff + doc_current_size;
	out_buff_last_pos = out_usds_buff + new_size;

	return 0;
};

inline int UsdsDomParser::addVarint(int value)
{
	if (value < 0)
		return -1;

	// step 1 of 5
	memcpy(out_buff_current_pos, &value, 4);
	out_buff_current_pos++;
	if (value < 128)
		return 0;

	// step 2 of 5
	out_buff_current_pos[3] = 0;
	*((int*)out_buff_current_pos) <<= 1;
	if (*(out_buff_current_pos - 1) & 128)
		*out_buff_current_pos |= 1;
	else
		*(out_buff_current_pos - 1) |= 128;

	out_buff_current_pos++;
	if (value < 16384)
		return 0;

	// step 3 of 5
	*((int*)out_buff_current_pos) <<= 1;
	if (*(out_buff_current_pos - 1) & 128)
		*out_buff_current_pos |= 1;
	else
		*(out_buff_current_pos - 1) |= 128;
	out_buff_current_pos++;
	if (value < 2097152)
		return 0;

	// step 4 of 5
	*((int*)out_buff_current_pos) <<= 1;
	if (*(out_buff_current_pos - 1) & 128)
		*out_buff_current_pos |= 1;
	else
		*(out_buff_current_pos - 1) |= 128;
	out_buff_current_pos++;
	if (value < 268435456)
		return 0;

	// step 5 of 5
	*((int*)out_buff_current_pos) <<= 1;
	if (*(out_buff_current_pos - 1) & 128)
		*out_buff_current_pos |= 1;
	else
		*(out_buff_current_pos - 1) |= 128;
	out_buff_current_pos++;

	return 0;
};

inline void UsdsDomParser::addLEInt(int value)
{
	memcpy(out_buff_current_pos, &value, 4);
	out_buff_current_pos += 4;
	return;
};

inline void UsdsDomParser::addLETimestamp64(time_t value)
{
	memcpy(out_buff_current_pos, &value, 8);
	out_buff_current_pos += 8;
	return;
};

inline void UsdsDomParser::addLEDouble(double value)
{
	memcpy(out_buff_current_pos, &value, 8);
	out_buff_current_pos += 8;
	return;
};

inline int UsdsDomParser::addStringUTF8NoConvert(const char* value, int max_size)
{
	// add string size in unsigned varint BASE128
	int str_size = strlen(value);
	if (str_size<0 || str_size >= max_size)
		return -1;
	addVarint(str_size);
	// add string without NULL-simbol
	memcpy(out_buff_current_pos, value, str_size);
	out_buff_current_pos += str_size;

	return 0;
};

inline void UsdsDomParser::addBool(bool value)
{
	if (value)
		*out_buff_current_pos = 255;
	else
		*out_buff_current_pos = 0;
	out_buff_current_pos++;
	return;
}


//====================================================================================================================
inline int UsdsDomParser::getVarint(int* value)
{
	int step = 0;
	int buf = 0;
	*value = 0;
	while (true)
	{
		buf = (*in_buff_current_pos) & 127;
		*value += (buf << (step * 7));
		if (*in_buff_current_pos < 128)
			break;
		in_buff_current_pos++;
		step++;
		if (in_buff_current_pos >= in_buff_body_last_pos)
			return -2;
		if (step == 5)
			return -1;
	};
	if (step == 4 && (*in_buff_current_pos) > 7)
		return -3;

	in_buff_current_pos++;

	return 0;
};

inline void UsdsDomParser::getLEInt(int* value)
{
	memcpy(value, in_buff_current_pos, 4);
	in_buff_current_pos += 4;

};

inline void UsdsDomParser::setLETimestamp64(time_t* value)
{
	memcpy(value, in_buff_current_pos, 8);
	in_buff_current_pos += 8;
};

inline void UsdsDomParser::setLEDouble(double* value)
{
	memcpy(value, in_buff_current_pos, 8);
	in_buff_current_pos += 8;
};

inline int UsdsDomParser::setStringUTF8NoConvert(char* value, int max_size)
{
	// read size of string
	int string_size;
	if (getVarint(&string_size) != 0)
		return -2;
	if (string_size >= max_size)
		return -3;
	if (in_buff_body_last_pos - in_buff_current_pos < string_size)
		return -4;
	memcpy(value, in_buff_current_pos, string_size);
	value[string_size] = 0;
	in_buff_current_pos += string_size;


	return 0;
};

inline void UsdsDomParser::setBool(bool* value)
{
	if (*in_buff_current_pos == 255)
		*value = true;
	else
		*value = false;
	in_buff_current_pos++;

}



//====================================================================================================================

UsdsVoucher* UsdsTicketSales::addToVouchers()
{
	UsdsVoucher* object = allocator->addUsdsVoucher();
	object->init(this, firstInVouchers, 0);

	if (firstInVouchers == 0)
		firstInVouchers = object;
	else
		lastInVouchers->setNextObject(object);
	lastInVouchers = object;
	vouchersSize++;

	return object;
}